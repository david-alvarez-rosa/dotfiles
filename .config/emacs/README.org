#+title: GNU Emacs Configuration
#+language: en
#+author: David Álvarez Rosa
#+email: david@alvarezrosa.com
#+description: My personal GNU Emacs configuration file.
#+property: header-args :tangle init.el


GNU Emacs is a free (as in /freedom/) +operating system+ text editor, created
by GNU Project founder Richard Matthew Stallman. I've been using this
magnificent piece of software daily for years now and I can assure you that
is--without a doubt--the best multi-purpose program ever written,
over-performing any other so-called text editors, such as Vi(m)--the editor of
the beast-- or, even worse, Microsoft VS Code malware, among others. I consider
myself a member of the Church of Emacs, my only religion, and I'm a firmly
believer in St. I-GNU-cius--who is a saint, but not a virgin--and to whom I
pray daily. In my day-to-day life I try to stick to the FOSS philosophy, while
living a life of moral chastity and purity, pursuing sainthood mainly through
extensively using org-mode.

There are some people out there that don't really get the meaning and purpose
of Emacs. They think that it is just another bloated text editor that doesn't
adhere to the KISS principle or the Unix philosophy. It is not. First, it is
not a text editor, it is a Lisp interpreter (actually, Elisp), a
Turing-complete programming language (therefore, offering limitless
possibilities). Secondly, there is no contradiction between using Emacs and
KISS or Unix philosophy: Emacs--at least for me--is a container for
"do-one-thing-and-do-it-well" packages that behave similarly, I find no
conflict here. Lastly, Emacs is a gift from God.

* Preamble
** Installation
This configuration is written in a literate style using Org mode (an Emacs
major mode). I do not recommend using this configuration "as is", but take it
as an inspiration for your own personal config. However, if you want to use it
that way, it's posible. You just need to start with a bare Emacs installation
(i.e., without any =.emacs= file in your home directory or =.emacs.d=
directory). With this done, just:
- Download this =init.org= file
- Create =.config/emacs/= directory if it does not exists.
- Open it with Emacs and press the function =C-c C-v C-t= for tangling all the
  source code blocks, i.e, call the function =org-babel-tangle= that will
  extract all source blocks from this file and write them into a file called
  =init.el= (inside the previously created directory).
- Open Emacs and enjoy!

  *NOTE:* First time you launch Emacs all needed packages will be
  /automagically/ installed for you, so you will need to wait for a couple of
  minutes. After that, Emacs will launch much faster.

** About this Configuration
Underlying principles:
- Built-in alternatives have been preferred to standalone (M)ELPA packages.
- User define commands are usually bound with =C-c= prefix, to avoid clashing
  with Emacs defaults (that usually use =C-x=).
- Minimalist, yet powerful.

Some utilities:
- Email Management, with mu4e and bound to =C-c e= ("e" for email).
- Web Feed Reader, with Elfeed. Bound to =C-c f= ("f" for feed).
- Org mode Agenda, bound to =C-c a= ("a" for agenda).
- Music Management, bound to =C-c m= ("m" for music).
- IRC client, with ERC. Bound to =C-c i= ("i" for IRC).
- Trasparency alpha toggler. Bound to =C-c b= ("b" for background).
- Terminal launcher. Bound to =C-c t= ("t" for terminal).
- Light/Dark theme. Bound to =C-c d= ("d" for dark). This cycles themes.
- Git, with Magit, bound to =C-c g= ("g" for git).
- Kill all buffers except current and *scratch*. Bound to =C-c k= ("k" for
  killing). This is kind of "restaring" Emacs session without actually closing
  it.

Conventions:
- Functions and variables defined by me are prefixed with my name and a slash,
  i.e., =dalvrosa/= to namespace them and avoid conflicts.

** License and Copyright
Copyright 2017-2025 David Álvarez Rosa.

Files are licensed under the same license as Emacs (GPL) unless otherwise
specified. See the LICENSE file for more information.

Any external/third party works included in this work are licensed under their
own licenses--refer to the submodules or packages for more information.

* Loading and Package Management
Make startup faster by reducing the frequency of garbage collection and then
use a hook to lower threshold back after Emacs startup. The loading time can be
check with the function =emacs-init-time=.
#+begin_src elisp
  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (expt 2 23))))
#+end_src

Add MELPA package repositories.
#+begin_src elisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
#+end_src

Always ensure that all package are installed when starting Emacs. If a
particular package does not exist, it will be installed automagically.
#+begin_src elisp
  ;; (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
#+end_src

* General Configuration
This section contains all configuration related to main settings for built-in
Emacs features.

** Personal Information
Basic personal information (name and mail address). Email variable will be
changed accordingly when using =mu4e= contexts (see configuration below).
#+begin_src elisp
  (setq user-full-name "David Álvarez Rosa")
  (setq user-mail-address "david@alvarezrosa.com")
#+end_src

** Server Mode
Start the Emacs server mode from this instance, so that all =emacsclient= calls
are routed here. This way, files can be sent to the current Emacs instance,
instead of opening a new one (much faster).
#+begin_src elisp
  (server-start)
#+end_src

** Custom File
Place all custom-defined variables in their own file and store the custom
variable file in the local machine’s home directory outside of version
control. This enables us to keep specific config local to each machine.
#+begin_src elisp
  (setq custom-file "~/.config/emacs/custom.el")
  (load custom-file t)
#+end_src

** Authentication File
The auth-source library is simply a way for Emacs and Gnus, among others, to
answer the old burning question “What are my user name and password?”

This is used for email and IRC log in, among others. The authentication file
looks as follows.
#+begin_src conf :tangle no
  machine mymachine login myloginname password mypassword port myport
  #+end_src

Customize location of authentication file (following XDB Base Directory
specification).
#+begin_src elisp
  (setq auth-sources '("~/.local/share/authinfo.gpg"))
#+end_src

** Initialization MacOS
I currently use Mac on my work laptop, and there are some specific things to
OS X.

Ensure environment variable inside Emacs look the same as shell.
#+begin_src elisp
  (when (eq system-type 'darwin)
    (use-package exec-path-from-shell
      :demand t
      :config
      (exec-path-from-shell-initialize)))
#+end_src

Append to path for using mu4e.
#+begin_src elisp
  (when (eq system-type 'darwin)
    (add-to-list 'load-path "/opt/homebrew/share/emacs/site-lisp/mu/mu4e"))
#+end_src

When opening from command line with ~open~ or Finder, don't open in new
frame.
#+begin_src elisp
  (setq ns-pop-up-frames nil)
#+end_src

Fix a bug with SVG that is already fixed in Emacs 29.
#+begin_src elisp
  (when (eq system-type 'darwin)
    (add-to-list 'image-types 'svg))
#+end_src

** File Management
Configuration related to file management.

*** Dired Mode
Dired is the main mode for Emacs file-manager operations. The name “Dired”
stands for “directory editor”.

Dired buffer can be modified by making them editable presing =C-x C-q=. With
this is posible to bulk-rename files, or to change file ownerships and
privileges, just thinking about the file listing as an (Emacs) editable text
file.

Show file sizes in a human readable style.
#+begin_src elisp
  (setq-default dired-listing-switches "-alh --group-directories-first")
  (when (eq system-type 'darwin)
    (setq insert-directory-program "/opt/homebrew/bin/gls"))
#+end_src

**** Dired Narrow
This package provides live filtering of files in dired buffers. In general,
after calling the respective narrowing function you type a filter string into
the minibuffer. With =/= start fuzzy matching, then use the dired buffer as
usual, and =g= for going back to the complete file listing.
#+begin_src elisp
  (use-package dired-narrow
    :after dired
    :bind (:map dired-mode-map
                ("/" . 'dired-narrow-fuzzy)))
#+end_src

**** Dired Subtree
Subtree by tabbing.
#+begin_src elisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :bind
    ( :map dired-mode-map
      ("<tab>" . dired-subtree-toggle))
    :config
    (setq dired-subtree-use-backgrounds nil))
#+end_src

*** File Backups, Autosaves and Interlock
Keep backups, autosaves and interlocks in the "temp" directory. Take into
account that this is a dangerous option with respect the disappearance of
files, but I always use version control for important projects, so that is not
a problem for me.
#+begin_src elisp
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
  (setq lock-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+end_src

** Buffer Management
Buffers, in Emacs terminology, hold the contents that display/edit in
windows. This are the configurations I use.

Change the threshold for windows split.
#+begin_src elisp
  (setq split-width-threshold 210)
#+end_src

*** Ibuffer Mode
Ibuffer is an advanced replacement for BufferMenu, which lets you operate on
buffers much in the same manner as Dired. The most important Ibuffer features
are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.
#+begin_src elisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Start in expert mode (without asking for confirmation).
#+begin_src elisp
  (setq ibuffer-expert t)
#+end_src

Kill current buffer without asking for which buffer to kill.
#+begin_src elisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+end_src

*** Narrowing
Narrowing buffers is very useful, however this commands are disabled by default
because new users often find them confusing. However, this configuration is
*not* for newbies, so enable them.
#+begin_src elisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'LaTeX-narrow-to-environment 'disabled nil)
#+end_src

I use =C-x n n= for narrowing to region and then =C-x n w= for widen (i.e.,
reverting to full page), but there are more narrow functions (enviroment
dependent), e.g., =C-x n d= for narrowing to defun (useful for narrowing
functions).

** Window Management
Split and follow for creating new windows.
#+begin_src elisp
  (defun dalvrosa/split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'dalvrosa/split-and-follow-horizontally)

  (defun dalvrosa/split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'dalvrosa/split-and-follow-vertically)
#+end_src

New bind for killing buffer *and* window at the same time. To do this press
=C-x C-k=, by default is bind to =C-x 4 0=, that is far more complex.
#+begin_src elisp
  (global-set-key (kbd "C-x C-k") 'kill-buffer-and-window)
#+end_src

Kill all buffers except =*scratch*= (similar to restarting Emacs).
#+begin_src elisp
  (defun dalvrosa/kill-all-other-buffers ()
    "Kill all buffers except current and *scratch*."
    (interactive)
    (delete-other-windows)
    (setq scratch (get-buffer "*scratch*"))
    (mapc 'kill-buffer (delq scratch (delq (current-buffer) (buffer-list)))))
  (global-set-key (kbd "C-c k") 'dalvrosa/kill-all-other-buffers)
#+end_src

*** Winner Mode
Global minor mode that allows to “undo” and “redo” changes in window
configuration. It is included in GNU Emacs.
#+begin_src elisp
  (winner-mode 1)
#+end_src

*** Window Move
Integration with i3wm https://sqrtminusone.xyz/posts/2021-10-04-emacs-i3/
#+begin_src elisp
    (global-set-key (kbd "M-o") 'other-window)

    (require 'windmove)
    (require 'cl-lib)

  (setq frame-title-format '("" "%b - GNU Emacs at " system-name))

    (defmacro dalvrosa/i3-msg (&rest args)
      `(start-process "emacs-i3-windmove" nil "i3-msg" ,@args))

    (defun dalvrosa/emacs-i3-windmove (dir)
      (let ((other-window (windmove-find-other-window dir)))
        (if (or (null other-window) (window-minibuffer-p other-window))
            (dalvrosa/i3-msg "focus" (symbol-name dir))
          (windmove-do-window-select dir))))

    (defun dalvrosa/emacs-i3-direction-exists-p (dir)
      (cl-some (lambda (dir)
                 (let ((win (windmove-find-other-window dir)))
                   (and win (not (window-minibuffer-p win)))))
               (pcase dir
                 ('width '(left right))
                 ('height '(up down)))))

    (defun dalvrosa/emacs-i3-move-window (dir)
      (let ((other-window (windmove-find-other-window dir))
            (other-direction (dalvrosa/emacs-i3-direction-exists-p
                              (pcase dir
                                ('up 'width)
                                ('down 'width)
                                ('left 'height)
                                ('right 'height)))))
        (cond
         ((and other-window (not (window-minibuffer-p other-window)))
          (window-swap-states (selected-window) other-window))
         (other-direction
          (evil-move-window dir))
         (t (dalvrosa/i3-msg "move" (symbol-name dir))))))

    (defun dalvrosa/emacs-i3-integration (command)
      (pcase command
        ((rx bos "focus")
         (dalvrosa/emacs-i3-windmove
          (intern (elt (split-string command) 1))))
        ((rx bos "move")
         (dalvrosa/emacs-i3-move-window
          (intern (elt (split-string command) 1))))
        (- (dalvrosa/i3-msg command))))
#+end_src

** Auto Fill Mode
Long lines are a bad practice. Please, don't use them, I find them quite
annoying. Stick to at most 80 characters. Use =M-q= for filling paragraphs when
editing (i.e., always ensure the =fill-column= limit).
#+begin_src elisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (setq-default fill-column 79)
  (add-hook 'text-mode-hook
            (lambda ()
              (set-fill-column 72)))
#+end_src

Custom unfill function with =M-Q=.
#+begin_src elisp
  (defun dalvrosa/unfill-paragraph (&optional region)
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive (progn (barf-if-buffer-read-only) '(t)))
    (let ((fill-column (point-max))
          ;; This would override `fill-column' if it's an integer.
          (emacs-lisp-docstring-fill-column t))
      (fill-paragraph nil region)))
  (define-key global-map (kbd "M-Q") 'dalvrosa/unfill-paragraph)
#+end_src

Custom function for killing region after unfill with =M-W=.
#+begin_src elisp
  (defun dalvrosa/unfill-paragraph-and-kill (beg end)
    "Save the current region to the kill ring after unfilling it."
    (setq dalvrosa/previous-major-mode major-mode)
    (interactive "r")
    (copy-region-as-kill beg end)
    (with-temp-buffer
      (funcall dalvrosa/previous-major-mode)
      (yank)
      (dalvrosa/unfill-paragraph (mark-whole-buffer))
      (mark-whole-buffer)
      (kill-region (point-min) (point-max))))
  (define-key global-map (kbd "M-W") 'dalvrosa/unfill-paragraph-and-kill)
#+end_src

** Indentation Enhancements
Allow easier indentation with better keys after calling =indent-rigidly=
function with =C-x TAB=.
#+begin_src elisp
  (define-key indent-rigidly-map "<" 'indent-rigidly-left)
  (define-key indent-rigidly-map "b" 'indent-rigidly-left)
  (define-key indent-rigidly-map ">" 'indent-rigidly-right)
  (define-key indent-rigidly-map "f" 'indent-rigidly-right)
  (define-key indent-rigidly-map "B" 'indent-rigidly-left-to-tab-stop)
  (define-key indent-rigidly-map "F" 'indent-rigidly-right-to-tab-stop)
#+end_src

** Subword Mode
Emacs treats camelCase strings as a single word by default, change this
behaviour.
#+begin_src elisp
  (global-subword-mode 1)
#+end_src

** Region Selection
In Emacs terminology the region is the selected portion of the text.

Real Emacs knights don't use shift to mark things, so disable it.
#+begin_src elisp
  (setq shift-select-mode nil)
#+end_src

Set delete selection mode, so typed text replaces the selection if the
selection is active. Otherwise, typed text is just inserted at point regardless
of any selection.
#+begin_src elisp
  (delete-selection-mode 1)
#+end_src

*** Expand Region
Expand region increases the selected region by semantic units. Just keep
pressing the key until it selects what you want. Expand region is done by
pressing ~C-=~ and contracting by prefixing the shortcut with a negative
argument argument, i.e., ~C-- C-=~.
#+begin_src elisp
  (use-package expand-region
    :bind ("C-=" . 'er/expand-region))
#+end_src

*** Upcase/Downcase Region
Command for upcasing =C-x C-u= or downcasing =C-x C-l= current region are also
disabled by default, enable them.
#+begin_src elisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

** Scrolling and Point Location
I personally don't like automatic scrolling (centering point vertically in the
window when point moves out of the visible portion of the text) so I have it
disabled (just set the following number to a large number, greater than 100).
#+begin_src elisp
  (setq scroll-conservatively 101)
#+end_src

Set keys for forward/backward between paragraphs (this is similar to =C-f= vs
=M-f=) .
#+begin_src elisp
  (define-key global-map (kbd "M-n") 'forward-paragraph)
  (define-key global-map (kbd "M-p") 'backward-paragraph)
#+end_src

Scroll window pane with keyboard, but without changing cursor line.
#+begin_src elisp
  (global-set-key (kbd "C-M-n") 'scroll-up-line)
  (global-set-key (kbd "C-M-p") 'scroll-down-line)
#+end_src

Controls if scroll commands move point to keep its screen position unchanged. A
value of t means point keeps its screen position if the scroll command moved it
vertically out of the window, e.g. when scrolling by full screens.
#+begin_src elisp
  (setq scroll-preserve-screen-position t)
#+end_src

With =C-x C-n= Use the current column of point as the semipermanent goal column
for =C-n= and =C-p= in the current buffer. When a semipermanent goal column is
in effect, those commands always try to move to this column, or as close as
possible to it, after moving vertically. The goal column remains in effect
until canceled (with =C-u C-x C-n=). This command is disabled by default, I
enable it.
#+begin_src elisp
  (put 'set-goal-column 'disabled nil)
#+end_src

Right and left scrolling commands are trigered with =C-c >= and =C-c <=
respectively. Scroll left is disabled by default, I enable it.
#+begin_src elisp
  (put 'scroll-left 'disabled nil)
#+end_src

Two very useful commands for recentering window are =C-l= and =C-M-l=, the
former is a well-known Emacs command, and the latter is for =reposition-window=
function, that makes the current definition and/or comment visible (i.e., it
attempts to scroll the window so the maximum content is visible).

Just scroll amount to just half a page.
#+begin_src elisp
  (global-set-key (kbd "C-v") 'View-scroll-half-page-forward)
  (global-set-key (kbd "M-v") 'View-scroll-half-page-backward)
#+end_src

** Character Pairs
It can be useful to insert parentheses, braces, quotes and the like in matching
pairs, e.g., pressing “(” inserts "()", with the cursor in between.
#+begin_src elisp
  (electric-pair-mode t)
#+end_src

Highlight matching braces.
#+begin_src elisp
  (show-paren-mode 1)
#+end_src

** HTML Renderer
Configure shr HTML render engine for converting HTML to text. I like the HTML
to be converted to text, without fancy fonts, and filled to 72 characters.
#+begin_src elisp
  (setq shr-use-fonts nil)
  (setq shr-width 72)
#+end_src

** Completion Inteface
+After years using Helm I have decided to switch to Ivy, Counsel and
Swiper as completion framework.+

After years using Ivy, Counsel and Swiper, I decided to switch to
Vertico, Consult and Corfu as completion framework.

Vertico provides a performant and minimalistic vertical completion UI
based on the default completion system.
#+begin_src elisp
  (use-package vertico
    :init
    (vertico-mode))
#+end_src

Consult provides search and navigation commands based on the Emacs
completion function completing-read.
#+begin_src elisp
  (use-package consult
    :bind (
           ("C-c m" . consult-man)
           ;; ("C-c i" . consult-info)
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-Too-buffer
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-fd)                  ;; Alternative: consult-find
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("C-s" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; below line allows to escape spaces while searching
    (setq orderless-component-separator 'orderless-escapable-split-on-space)
    :config
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-buffer consult-buffer-other-tab consult-buffer-other-window
     consult-project-buffer
     consult-buffer-other-frame consult-ripgrep consult-git-grep consult-grep
     consult-man consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     :preview-key "M-."))
#+end_src

Save mini-buffer history.
#+begin_src elisp
  (savehist-mode)
#+end_src

Corfu enhances completion at point with a small completion popup.  The
current candidates are shown in a popup below or above the point.  Corfu
is the minimalistic ~completion-in-region~ counterpart of the Vertico
minibuffer UI.
#+begin_src elisp
  (use-package corfu
    :init
    (global-corfu-mode)
    :config
    (setq corfu-auto t)
    (setq corfu-auto-prefix 2)
    (setq corfu-auto-delay 0.1)
    (setq corfu-popupinfo-delay 0.5)
    (corfu-popupinfo-mode 1)
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)
    (setq text-mode-ispell-word-completion nil))
#+end_src

This package provides an ~orderless~ completion style that divides the
pattern into space-separated components, and matches candidates that
match all of the components in any order.  Each component can match in
any one of several ways: literally, as a regexp, as an initialism, in
the flex style, or as multiple word prefixes.  By default, regexp and
literal matches are enabled.
#+begin_src elisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src

This package provides ~marginalia-mode~ which adds marginalia to the
minibuffer completions.  Marginalia are marks or annotations placed at
the margin of the page of a book or in this case helpful colorful
annotations placed at the margin of the minibuffer for your completion
candidates.  Marginalia can only add annotations to the completion
candidates.  It cannot modify the appearance of the candidates
themselves, which are shown unaltered as supplied by the original
command.
#+begin_src elisp
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

Cape provides Completion At Point Extensions which can be used in
combination with Corfu, Company or the default completion UI.
#+begin_src elisp
  (use-package cape
    :init
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-tex))
#+end_src

Embark is an Emacs mini-buffer actions rooted in keymaps.
#+begin_src elisp
  (use-package embark
    :bind
    (("C-." . embark-act)
     ("C-;" . embark-dwim)))

  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Keybinding Panel
Nice utility (=which-key=) for displaying available keybindings in a popup
panel. You get an overview of what keybindings are available based on the
prefix keys you entered.
#+begin_src elisp
  (use-package which-key
    :init (which-key-mode))
#+end_src

** Spell Checking and Correcting
Commands to check the spelling of a single word or of a portion of a
buffer.  These commands only work if a spelling checker program, one of
Hunspell, Aspell, Ispell or Enchant, is installed. These programs are
not part of Emacs, but one of them is usually installed on GNU/Linux and
other free operating systems. I have installed Hunspell with =pacman -S
hunspell hunspell-en_us hunspell-es_ES= (for isntalling english and
spanish dictionaries).

I set the default dictionary to english, since I write more in english than in
spanish these days. This can be changed with =ispell-change-dictionary=
function.
#+begin_src elisp
  (setq ispell-program-name "hunspell")
  (setq ispell-dictionary "english")
#+end_src

Main command for spell checking is =M-$= for check and correct pelling of the
word at point, but if the region is active, do it for all words in the region
instead. When this command encounters what appears to be an incorrect word, it
asks you what to do, here are some valid responses (see them all with =?=):
- =digit= for replacing the word.
- =SPC= for skipping this word, and continue.
- =r= replace the word with some user-defined string.
- =a= accept the word only in this editing session (there is =A= variant, for
  only in this buffer).
- =i= insert word to personal dictionary (there is =u= variant, for inserting
  the lowercase version of that word in the dictionary).

It is also useful the use spelling *on the fly* with =flyspell-mode=, that
highlights all misspelled words (the variant =flyspell-prog-mode= is for
programming language, where spelling should occur only for comments and
strings). I have enabled it by default.
#+begin_src elisp
  (add-hook 'text-mode-hook 'flyspell-mode)
  ;; (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src

** Sudo Edit
Utility for opening files with =sudo= (call the =sudo-edit= function).
#+begin_src elisp
  (use-package sudo-edit)
#+end_src

** Chronometer
#+begin_src elisp
  (use-package chronometer)
#+end_src

** Disable Kill Confirmation
#+begin_src elisp
  (setq confirm-kill-processes nil)
#+end_src

** Engine Mode
~engine-mode~ is a global minor mode for Emacs.  It enables you to
easily define search engines, bind them to keybindings, and query them
from the comfort of your editor.
#+begin_src elisp
  (use-package engine-mode
    :config
    (defengine DuckDuckGo
      "https://duckduckgo.com/?q=%s&t=h_"
      :keybinding "d")
    (engine-mode t))
#+end_src

** LLM Integration
Currently using [[https://github.com/karthink/gptel][gptel]], a simple Large Language Model chat client for
Emacs, with support for multiple models and backends. It works in the
spirit of Emacs, available at any time and uniformly in any buffer.

#+begin_src elisp
  (defun dalvrosa/new-gpt-chat ()
    (interactive)
    (switch-to-buffer (gptel (generate-new-buffer "*ChatGPT*"))))

  (use-package gptel
    :bind
    ("C-c h" . dalvrosa/new-gpt-chat)
    :config
    (setq gptel-model 'gpt-4.1)
    (setq gptel-default-mode 'org-mode)
    :hook (gptel-mode . visual-line-mode))

  (gptel-make-anthropic "Claude" :stream t :key gptel-api-key)
#+end_src

* User Interface
Settings related to the user interface, such as the theme, the modeline, the
font, other basic interface settings, and the transparency alpha.

** Theme
Consider all custom themes as safe (don't ask for confirmation when loading
it).
#+begin_src elisp
  (setq custom-safe-themes t)
#+end_src

I have recently started using Protesilaos Stavrou nerdy high-contrast themes.
#+begin_src elisp
  (load-theme 'modus-operandi)
  (global-set-key (kbd "C-c d") 'modus-themes-toggle)
#+end_src

** Icons
Add some nerd-icons here and there.
#+begin_src elisp
  (use-package nerd-icons
    :demand t)

  (use-package nerd-icons-completion
    :after marginalia
    :init
    (nerd-icons-completion-mode)
    (nerd-icons-completion-marginalia-setup))

  (use-package nerd-icons-corfu
    :demand t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-dired
    :hook
    (dired-mode . nerd-icons-dired-mode))
#+end_src

** Modeline
For the modeline I am using also Doom Modeline. This package requires the fonts
included with =nerd-icons= to be installed with =M-x
nerd-icons-install-fonts=. I have configured it to show column number
instead of percentage buffer position.
#+begin_src elisp
  (use-package doom-modeline
    :demand t
    :init (doom-modeline-mode 1)
    :config
    (setq display-time-default-load-average nil)
    (setq column-number-mode t)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project))
#+end_src

Enable nyan cat.
#+begin_src elisp
  (use-package nyan-mode
    :after doom-modeline
    :init (nyan-mode)
    (nyan-start-animation))
#+end_src

** Font
Set default font. I'm currently using Hack (in the past I used Inconsolata).
#+begin_src elisp
  (set-face-attribute 'default nil :font "Hack Nerd Font" :height 90)
#+end_src

** Basic Interface Settings
Settings related to built-in enhancements of the UI that do not depend on any
external package.

*** Disable Menus and Scrollbars
Disable tool bar, menu bar and scroll bar. All three are very ugly and
unnecesary. Might be handy for normies, but not for chad Emacs users. Basically
this turns off al the mouse interface.
#+begin_src elisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (tooltip-mode 0)
#+end_src

*** Remove Startup Screen
Inhibit lame startup screen.
#+begin_src elisp
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+end_src

*** Highlight Cuurrent Line
Pretty nice UI enhancement for finding current line. It does not look good in
the terminal version of Emacs, though, so it's not set there.
#+begin_src elisp
  (when window-system (global-hl-line-mode t))
#+end_src

** Distraction Free Mode
Olivetti is a simple Emacs minor mode for a nice writing environment, that sets
a desired text body width to automatically resize window margins to keep the
text comfortably in the middle of the window. I use the default text body
width, that is =fill-colum= +2.
#+begin_src elisp
  (use-package olivetti
    :config
    (setq-default olivetti-body-width (+ fill-column 10))
    (setq olivetti-style 'fancy)
    :bind ("C-c o" . 'olivetti-mode))
#+end_src

This mode can be enabled with =olivetti-mode= in any buffer (everything it does
is buffer-local). And the, it has some commands:
- Shrink =C-c { { { ...=
- Expand =C-c } } } ...=
- Set width =C-c |=

* Programming Configuration
Configuration settings related to programming languages.

** General Configuration
Programming configuration that is not specific to one programming language.

*** Tree Sitter
Tree-sitter is a parser generator tool and an incremental parsing library. It
can build a concrete syntax tree for a source file and efficiently update the
syntax tree as the source file is edited. Watch this [[https://www.thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html][video]] for more
information.
#+begin_src elisp
  (use-package treesit-auto
    :demand t
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

*** Documentation
#+begin_src elisp
   (global-eldoc-mode)
#+end_src

*** Flymake
#+begin_src elisp
  (use-package flymake
    :hook (prog-mode . flymake-mode)
    :bind (:map flymake-mode-map
                ("C-c ! n" . flymake-goto-next-error)
                ("C-c ! p" . flymake-goto-prev-error)
                ("C-c ! l" . flymake-show-buffer-diagnostics)))
#+end_src

*** Terminal Emulator
Emacs-libvterm (vterm) is fully-fledged terminal emulator inside GNU
Emacs based on libvterm, a C library. As a result of using compiled code
(instead of elisp), emacs-libvterm is fully capable, fast, and it can
seamlessly handle large outputs.  I launch it with =C-c t= (with =C-u=
prefix will create a new session), and also with =C-x p v= when inside a
Projectile project.
#+begin_src elisp
  (use-package vterm
    :config
    (add-to-list 'vterm-eval-cmds '("man" man))
    (setq vterm-max-scrollback 10000)
    :bind ("C-c t" . 'vterm))
#+end_src

Don't ask for confirmation when killing vterm buffer.
#+begin_src elisp
  (setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+end_src

Configure vterm with ~projectile.el~ from
https://mocompute.codeberg.page/item/2024/2024-09-03-emacs-project-vterm.html
#+begin_src elisp
  (defun dalvrosa/project-shell ()
    "Start an inferior shell in the current project's root directory.
  If a buffer already exists for running a shell in the project's root,
  switch to it.  Otherwise, create a new shell buffer.
  With \\[universal-argument] prefix arg, create a new inferior shell buffer even
  if one already exists."
    (interactive)
    (require 'comint)
    (let* ((default-directory (project-root (project-current t)))
           (default-project-shell-name (project-prefixed-buffer-name "vterm"))
           (shell-buffer (get-buffer default-project-shell-name)))
      (if (and shell-buffer (not current-prefix-arg))
          (if (comint-check-proc shell-buffer)
              (pop-to-buffer shell-buffer (bound-and-true-p display-comint-buffer-action))
            (vterm shell-buffer))
        (vterm (generate-new-buffer-name default-project-shell-name)))))

  (with-eval-after-load 'project
    (add-to-list 'project-switch-commands '(consult-project-buffer "Find buffer") t)
    (add-to-list 'project-switch-commands '(magit-project-status "Magit") t)
    (add-to-list 'project-switch-commands '(dalvrosa/project-shell "Vterm") t)
    (keymap-set project-prefix-map "b" #'consult-project-buffer)
    (keymap-set project-prefix-map "g" #'magit-project-status)
    (keymap-set project-prefix-map "v" #'dalvrosa/project-shell))
#+end_src

*** Language Server Protocol
The goal of the language server protocol is to allow programming language
support to be implemented and distributed independently of any given editor.
#+begin_src elisp
  (use-package eglot
    :config
    (setq eglot-ignored-server-capabilities '(:inlayHintProvider))
    (setq eglot-autoshutdown t)
    :hook ((c++-ts-mode . eglot-ensure)
           (c-ts-mode . eglot-ensure)
           (java-ts-mode . eglot-ensure)
           (ruby-ts-mode . eglot-ensure)
           (rust-ts-mode . eglot-ensure)
           (python-ts-mode . eglot-ensure)
           (LaTeX-mode . eglot-ensure)
           (cmake-ts-mode . eglot-ensure)
           (php-ts-mode . eglot-ensure )
           (typescript-ts-mode . eglot-ensure)
           (js-ts-mode . eglot-ensure))
    :bind (:map eglot-mode-map
  	            ("C-c l a" . eglot-code-actions)
  	            ("C-c l r" . eglot-rename)
  	            ("C-c l h" . eldoc)
  	            ("C-c l f" . eglot-format)
  	            ("C-c l d" . xref-find-definitions-at-mouse))
    :commands eglot)
#+end_src

*** Debug Adapter Protocol
Emacs client/library for Debug Adapter Protocol is a wire protocol for
communication between client and Debug Server. It's similar to the LSP but
provides integration with debug server.
#+begin_src elisp
  (use-package dape
    :hook
    (kill-emacs . dape-breakpoint-save)
    (after-init . dape-breakpoint-load)
    :config
    (setq dape-inlay-hints nil))

  (repeat-mode)
#+end_src

*** Line Numbers
Display line numbers.
#+begin_src elisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

*** Tabs vs Spaces
A good programmer knows that spaces are by far a better alternative than tabs.
This doesn't mean you need to insert the spaces manually. Emacs will take care
of this for you.

Configure default tab width to 2 spaces.
#+begin_src elisp
  (setq-default tab-width 2)
#+end_src

Ensure spaces are entered when pressing the =TAB= key.
#+begin_src elisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** Trailing Whitespace
Delete (nasty) trailing whitespace when saving a file (this includes emtpy
lines at the end of the file and empty spaces at the end of lines).
#+begin_src elisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Magit
Magit is one of the killer features in Emacs, is a complete text-based user
interface to Git. It fills the glaring gap between the Git command-line
interface and various GUIs, letting you perform trivial as well as elaborate
version control tasks with just a couple of mnemonic key presses. Magit looks
like a prettified version of what you get after running a few Git commands but
in Magit every bit of visible information is also actionable to an extent that
goes far beyond what any Git GUI provides and it takes care of automatically
refreshing this output when it becomes outdated. In the background Magit just
runs Git commands and if you wish you can see what exactly is being run, making
it possible for you to learn the git command-line by using Magit.
#+begin_src elisp
  (use-package magit
    :bind ("C-c g" . 'magit-status))
#+end_src

Using Magit for a while will make you a more effective version control user.
Magit supports and streamlines the use of Git features that most users and
developers of other Git clients apparently thought could not be reasonably
mapped to a non-command-line interface. Magit is both faster and more intuitive
than either the command line or any GUI and these holds for both Git beginners
and experts alike.

Link to Magit buffers from Org documents.
#+begin_src elisp
  (use-package orgit)
#+end_src

*** Git Link
Interactive Emacs functions that create URLs for files and commits in
GitHub/Bitbucket/GitLab/... repositories.

- =git-link= returns the URL for the current buffer's file location at the
  current line number or active region.
- =git-link-commit= returns the URL for the commit at point.
- =git-link-homepage= returns the URL for the repository's homepage.

URLs are added to the kill ring.
#+begin_src elisp
  (use-package git-link
    :demand t
    :config
    (global-set-key (kbd "C-c w l") 'git-link)
    (global-set-key (kbd "C-c w c") 'git-link-commit)
    (global-set-key (kbd "C-c w h") 'git-link-homepage))
#+end_src

*** Snippets
YASnippets is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates.
#+begin_src elisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-reload-all)
    :hook ((prog-mode . yas-minor-mode)
           (LaTeX-mode . yas-minor-mode)))
#+end_src

Custom snippets are located in =.config/emacs/snippets= directory (best way to
create them is using =yas-new-snippet= function).

*** Ediff
Ediff provides a convenient way for simultaneous browsing through the
differences between a pair (or a triple) of files or buffers. The files being
compared, are shown in separate windows and the differences are highlighted as
you step through them. You can also copy difference regions from one buffer to
another (and recover old differences if you change your mind). Another powerful
feature is the ability to merge a pair of files into a third buffer.

Don't open new frame for setup window and prefer splitting horizontally.
#+begin_src elisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

*** Compilation
Enable Ansi Color colors in compilation window.
#+begin_src elisp
  (require 'ansi-color)
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+end_src

Automatically scroll the compilation output.
#+begin_src elisp
  (setq compilation-scroll-output t)
#+end_src

Automatically save without confirmation.
#+begin_src elisp
  (setq compilation-ask-about-save nil)
#+end_src

** CMake
Use CMake mode for editing CMakeLists.txt files.
#+begin_src elisp
  (use-package cmake-mode)
#+end_src

~eldoc-cmake~ shows documentation (using ~eldoc-mode~) when editing CMake files.
#+begin_src elisp
  (use-package eldoc-cmake
    :hook (cmake-mode . eldoc-cmake-enable))
#+end_src

** PHP
Just use the default mode.
#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.php\\'" . php-ts-mode))
#+end_src

** Kotlin
Enable Kotlin mode.
#+begin_src elisp
  (use-package kotlin-mode)
#+end_src

** Swift
Use ~swift-mode~ for editing Swift files.
#+begin_src elisp
  (use-package swift-mode)
#+end_src

** Octave/Matlab
Open Matlab files (.m) in Octave mode by default.
#+begin_src elisp
  (setq auto-mode-alist
        (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+end_src

** R
Use ESS package ("Emacs Speaks Statistics") for editing R code.
#+begin_src elisp
  (use-package ess)
#+end_src

Some useful commands:
- =C-c C-b= to eval buffer.
- =C-c C-j= to eval line.
- =C-c C-r= to eval region.
- =C-c C-f= to eval function.

** Apache Groovy
Apache Groovy is a Java-syntax-compatible object-oriented programming
language for the Java platform.  I'm using it mainly for editing
~guild.gradle~ files.
#+begin_src elisp
  (use-package groovy-mode)
#+end_src

** REST HTTP API
This is a tool to manually explore and test HTTP REST webservices.  Runs
queries from a plain-text query sheet, displays results as a
pretty-printed XML, JSON and even images.  Nice examples in package
[[https://github.com/pashky/restclient.el][README]].
#+begin_src elisp
  (use-package restclient
    :demand t
    :config (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+end_src

** Log Files
Emacs minor mode that allows viewing, editing, searching and comparing
large files in batches, trading memory for processor time. Batch size
can be adjusted on the fly and bounds the memory that is to be used for
operations on the file. This way multiple large files (like terabytes or
whatever) can be instantly and simultaneously accessed without swapping
and degraded performance.
#+begin_src elisp
  (use-package vlf
    :init (require 'vlf-setup))
#+end_src

* Org Mode
Configuration for Org mode, one of the best major modes (org mode is definately
an Emacs killer feature). Org mode is for keeping notes, maintaining to-do
lists, planning projects, authoring documents, computational notebooks,
literate programming and more-—in a fast and effective plain text system. I
mainly use it for organize my life, literate programming and even writting
emails.

** Speed Commands
Activate single letter commands at beginning of a headline.
#+begin_src elisp
  (setq org-use-speed-commands t)
#+end_src

This is very useful for navigating/modifying org mode files. I usually use
=n/p= for next/previous, =b/f= for backward/forward, and =l/r= for left/right.

** Refile
Configuration for refiling command =C-c C-w=.
#+begin_src elisp
  (setq org-refile-targets '((nil :maxlevel . 2)
                                  (org-agenda-files :maxlevel . 2)))
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path 'file)
#+end_src

** Capture Templates
Take notes quickly within Emacs with =C-c c=.
#+begin_src elisp
  (setq org-default-notes-file "~/docs/Agenda.org")
  (define-key global-map (kbd "C-c c") 'org-capture)
#+end_src

Set my custom capture templates. Brief description of them:
- Task: basic template for TODO tasks. This is inside my =Agenda.org= file under
  "Refile" heading. Then I manually refile this tasks under a particular
  projects or into a "Standalone Tasks" heading.
- Text Note: template for taking quick notes. This is inside my =Notes.org=
  file.
#+begin_src elisp
  (setq org-capture-templates
        '(("t" "Task" entry
           (file+olp "~/docs/Agenda.org" "Refile")
           "* TODO [#C] %?\n%a\n%i" :empty-lines 1)
          ("n" "Text Note" entry
           (file+olp "~/docs/Notes.org" "Refile")
           "* %?" :empty-lines 1)))
#+end_src

For the above email (or link) capture templates to work with =mu4e= (email
client used in this configuration), it is needed the following.
#+begin_src elisp
  (require 'mu4e-org)
#+end_src

Add some global key binding for storing link =C-c l= and jumping (goto) to
current clocked task.
#+begin_src elisp
  (global-set-key (kbd "C-c L") 'org-store-link)
  (global-set-key (kbd "C-c j") 'org-clock-goto)
#+end_src

** State Keywords
Custom todo keywords. I use them as follows:
  - TODO: task that needs to be done (in order, depending priority).
  - WAIT: I am waiting for something that does not depend on myself (i.e,
  something external).
  - NEXT: todo task, that is on-going or is next task to be done.
  - DONE: task is done.
  - CANCELLED: task is cancelled.
#+begin_src elisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "WAIT(w!)" "NEXT(n!)" "|"
                    "DONE(d!)" "CANCELLED(c!)")))
#+end_src

For tracking TODO state changes, the meaning of the characters is as follows
(check [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking TODO state changes]] for more information): ! for timestamp and @
for note with timestamp. I'm not using automatic notes anymore, those can be
recovered by prefixing state change with =C-u=.

Log state changes into drawer.
#+begin_src elisp
  (setq org-log-into-drawer t)
#+end_src

** Priorities
Allow priorities from A to D.
#+begin_src elisp
  (setq org-lowest-priority ?D)
#+end_src

** Code Evaluation
Allow code blocks in these languages to be evaluated with =C-c C-c=.
#+begin_src elisp
  (eval-after-load "org"
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((C . t)
           ;; (C++ . t)
           (python . t)
           (latex . t)
           (matlab . t)
           (shell . t)
           (css . t)
           (calc . t)
           (R . t)
           (js . t))))
#+end_src

Don't ask for confirmation for evaluating code.
#+begin_src elisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Export
Add export backends to (GitHub) MarkDown, Jira and Slack.
#+begin_src elisp
  (eval-after-load "org"
    '(require 'ox-md nil t))

  (use-package ox-jira
    :after org
    :init (require 'ox-jira nil t))

  (use-package ox-slack
    :after org
    :init (require 'ox-slack nil t))

  (use-package ox-gfm
    :after org
    :init (require 'ox-gfm nil t))
#+end_src

** Interface
Restore windows after quitting org agenda.
#+begin_src elisp
  (setq org-agenda-restore-windows-after-quit t)
#+end_src

*** List Configuration
Allow alphabetical list, i.e., list like "a)", "A" or "A)" as element lists.
#+begin_src elisp
  (setq org-list-allow-alphabetical t)
#+end_src

*** Indent Mode
Launch org mode in indent mode.
#+begin_src elisp
  (setq org-startup-indented t)
#+end_src

*** Initial Visibility
When Emacs first visits an Org file, set the global state to =content=, to show
only headers.
#+begin_src elisp
  (setq org-startup-folded 'content)
#+end_src

** Agenda
Set =C-c a= for opening org agenda. This is one of the features that I like the
most of Emacs. It's great.
#+begin_src elisp
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

Set files to show in agenda.
#+begin_src elisp
  (setq org-agenda-files '("~/docs/Agenda.org"))
#+end_src

Custom agenda views. I use a custom view that contains the following blocks:
  - Agenda for the current day (including habits).
  - NEXT tasks (that are not scheduled).
  - Tasks in the refile tree (waiting to be refiled).
  - Work related tasks.
  - Project tasks (i.e., tasks with :PROJ: tag). Only those that are not
    schedule.
  - Rest of standalone tasks. Also only those that are not schedule.
  - WAIT tasks.
#+begin_src elisp
  (setq org-agenda-custom-commands
        '((" " "Block Agenda"
           ((agenda "" ((org-agenda-span 1)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")
                   (org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'scheduled))))
            (tags-todo "+refile" ((org-agenda-overriding-header "Refile")))
            (tags-todo "TODO=\"TODO\"+proj-backlog"
                       ((org-agenda-overriding-header "Projects")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled))))
            (tags-todo "TODO=\"TODO\"+sing-backlog"
                       ((org-agenda-overriding-header "Standalone Tasks")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'scheduled))))
            (tags-todo "TODO=\"WAIT\"-backlog" ((org-agenda-overriding-header "Waiting")
                                                (org-agenda-skip-function
                                                 '(org-agenda-skip-entry-if 'scheduled))))))
          ("b" "Backlog"
           ((agenda "" ((org-agenda-span 1)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Actions")))
            (tags-todo "+refile" ((org-agenda-overriding-header "Refile")))
            (tags-todo "TODO=\"TODO\"+proj-backlog"
                       ((org-agenda-overriding-header "Projects")))
            (tags-todo "TODO=\"TODO\"+sing-backlog"
                       ((org-agenda-overriding-header "Standalone Tasks")))
            (tags-todo "TODO=\"WAIT\"-backlog"
                       ((org-agenda-overriding-header "Waiting")))
            (tags-todo "+backlog"
                       ((org-agenda-overriding-header "Backlog")))))))
#+end_src

While in this agenda view press =w= for changing the agenda span to full week
or =d= for just showing curren day. Also, it is posible to toggle log mode with
=l=.

Show all posible items that should in agenda log mode.
#+begin_src elisp
  (setq org-agenda-log-mode-items '(closed clock state))
#+end_src

Set deadline warning days to 7 (instead of the default 14 days).
#+begin_src elisp
  (setq org-deadline-warning-days 7)
#+end_src

With =q= bury agenda instead of killing it (faster of course).
#+begin_src elisp
  (setq org-agenda-sticky t)
#+end_src

How the agenda buffer should be displayed.  Show agenda in the current
window, keeping all other windows.
#+begin_src elisp
  (setq org-agenda-window-setup 'current-window)
#+end_src

I don't like empty blocks to show in customized agenda, so I hide them (this
code is from [[https://lists.gnu.org/archive/html/emacs-orgmode/2015-06/msg00266.html][emacs mail list]]).
#+begin_src elisp
  (defun dalvrosa/org-agenda-delete-empty-blocks ()
    "Remove empty agenda blocks.
    A block is identified as empty if there are fewer than 2
    non-empty lines in the block (excluding the line with
    `org-agenda-block-separator' characters)."
    (when org-agenda-compact-blocks
      (user-error "Cannot delete empty compact blocks"))
    (setq buffer-read-only nil)
    (save-excursion
      (goto-char (point-min))
      (let* ((blank-line-re "^\\s-*$")
             (content-line-count (if (looking-at-p blank-line-re) 0 1))
             (start-pos (point))
             (block-re (format "%c\\{10,\\}" org-agenda-block-separator)))
        (while (and (not (eobp)) (forward-line))
          (cond
           ((looking-at-p block-re)
            (when (< content-line-count 2)
              (delete-region start-pos (1+ (point-at-bol))))
            (setq start-pos (point))
            (forward-line)
            (setq content-line-count (if (looking-at-p blank-line-re) 0 1)))
           ((not (looking-at-p blank-line-re))
            (setq content-line-count (1+ content-line-count)))))
        (when (< content-line-count 2)
          (delete-region start-pos (point-max)))
        (goto-char (point-min))
        ;; The above strategy can leave a separator line at the beginning
        ;; of the buffer.
        (when (looking-at-p block-re)
          (delete-region (point) (1+ (point-at-eol))))))
    (setq buffer-read-only t))

  (add-hook 'org-agenda-finalize-hook #'dalvrosa/org-agenda-delete-empty-blocks)
#+end_src

*** Habits
Show a nice graph for recurring habits. See [[https://orgmode.org/manual/Tracking-your-habits.html][Tracking your Habits]] in the
Org-mode manual for more information.
#+begin_src elisp
  (require 'org-habit)
#+end_src

Configure the column the absolute column at which to insert habit consistency
graphs (consistency graph overwrites anything else in the buffer).
#+begin_src elisp
  (setq org-habit-graph-column 55)
#+end_src

*** Notifications
Enable notifications for scheduled tasks.
#+begin_src elisp
  (require 'appt)
  (setq appt-time-msg-list nil)
  (setq appt-message-warning-time '15
        appt-display-interval '5)

  (setq appt-display-mode-line nil
        appt-display-format 'window)
  (appt-activate 1)

  (org-agenda-to-appt)
  (run-at-time "24:01" 1800 'org-agenda-to-appt)
  (add-hook 'org-finalize-agenda-hook 'org-agenda-to-appt)

  (defun dalvrosa/appt-send-notification (title msg)
      (shell-command (concat "notify-send " msg " " title)))

  (defun dalvrosa/appt-display (min-to-app new-time msg)
    (dalvrosa/appt-send-notification
     (format "'Meeting in %s minutes'" min-to-app)
     (format "'%s'" msg)))
  (setq appt-disp-window-function (function dalvrosa/appt-display))
#+end_src

** Archive
Set default org archive location.
#+begin_src elisp
  (setq org-archive-location "::* Archived Items")
#+end_src

Use lowercase tag names.
#+begin_src elisp
  (setq org-archive-tag "archive")
#+end_src

* Markup Languages
Section for markup languages.

** Markdown Mode
Major mode for editting Markdown-formatted text.
#+begin_src elisp
  (use-package markdown-mode)
#+end_src

Markdown preview mode, just call ~markdown-preview-mode~ function.
#+begin_src elisp
  (use-package markdown-preview-mode
    :config
    (setq markdown-preview-stylesheets
          (list "https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.9.0/github-markdown.min.css"
                "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" "
    <style>
     .markdown-body {
       box-sizing: border-box;
       min-width: 200px;
       max-width: 980px;
       margin: 0 auto;
       padding: 45px;
     }

     @media (max-width: 767px) {
       .markdown-body {
         padding: 15px;
       }
     }
    </style>
  "))
    (setq markdown-preview-javascript
          (list "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" "
    <script>
     $(document).on('mdContentChange', function() {
       $('pre code').each(function(i, block) {
         hljs.highlightBlock(block);
       });
     });
    </script>
  ")))
#+end_src

** Quarto
#+begin_src elisp
  (use-package quarto-mode
    :mode (("\\.Rmd" . poly-quarto-mode)))
#+end_src

** TeX/LaTeX
AUCTeX is an extensible package for writing and formatting TeX files in GNU
Emacs. It supports many different TEX macro packages, including AMS-TeX, LaTeX,
Texinfo, ConTeXt, and docTeX (dtx files).
#+begin_src elisp
  (use-package latex
    :ensure auctex
    :config
    ;; Always in math mode
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    ;; Set PDF viewer to pdf-tools with correlation
    (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
    (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
    ;; Enable electric behavior.
    (setq TeX-electric-math t)
    (setq TeX-electric-sub-and-superscript t)
    ;; I want \items indented.
    (setq LaTeX-item-indent 0)
    :bind (
           :map LaTeX-mode-map
           ;; Command for cleaning auxiliary files
           ("C-x M-k" . 'TeX-clean)))
#+end_src

AUCTex is not just great, it's the best framework for writting LaTeX. This are
the commands I use the most:
- =C-c C-e= for inserting environment (figure, equation, table, etc.).
- =C-c C-m= for inserting macro (documentclass, usepackage, frac, etc.).
- =C-c C-s= for inserting section (chapter, section, subsection, etc.).
- =C-f- C-f C-*= is a font specifier (e.g., =C-c C-f C-b= inserts bold face).
  Very useful when region is active. For deleting (innermost) font
  specification use =C-c C-f C-d=.
- =C-c ]= for ending current environment.
- =C-M-a= and =C-M-e= for moving point to begin or end of current environment.
- =` *= for entering mathematical symbols (e.g., =` a= for inserting =\alpha=).
- =C-c .= for marking current environment and =C-c *= for marking current
  section.

CDLaTeX provides a collection of convenience functions that speed up
editing LaTeX documents.
#+begin_src elisp
  (use-package cdlatex
    :hook (LaTeX-mode . turn-on-cdlatex))
#+end_src

*** RefTeX
RefTeX is a specialized package for support of labels, references, citations,
and the index in LaTeX. RefTeX wraps itself round four LaTeX macros: =\label=,
=\ref=, =\cite=, and =\index=. Using these macros usually requires looking up
different parts of the document and searching through BibTeX database files.
RefTeX automates these time-consuming tasks almost entirely. It also provides
functions to display the structure of a document and to move around in this
structure quickly.
- =C-c == show ToC.
- =C-c (= create label.
- =C-c )= reference label.
- =C-c [= create cite.
- =C-c /= for creating an index.
#+begin_src elisp
  (setq reftex-plug-into-AUCTeX t)
  (setq reftex-toc-split-windows-fraction 0.2)
#+end_src

*** Compilation
Compile always with =-shell-escape= flag. I usually need this for PGF/TikZ or
Minted.
#+begin_src elisp
  (setq TeX-command-extra-options "-shell-escape -synctex=1")
#+end_src

Don't ask for confirmation when saving and update output PDF after compilation.
#+begin_src elisp
  (setq TeX-save-query nil)
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
#+end_src

*** BibTeX
For managing .bib files. Use =C-c C-c=. Insert entries templates with different
key bindings. Also, =C-c C-f= for inserting new field.
#+begin_src elisp
  (setq bibtex-align-at-equal-sign t)
  (setq bibtex-entry-format `(opts-or-alts required-fields
                              numerical-fields whitespace realign
                              last-comma delimiters unify-case
                              braces sort-fields))
  (setq bibtex-autokey-year-title-separator ":")
#+end_src

** Ledger
Ledger is a powerful, double-entry accounting system that is accesed from the
UNIX command line.
#+begin_src elisp
  (use-package ledger-mode)
#+end_src

** YAML
Add major mode for editing YAML.
#+begin_src elisp
  (use-package yaml-mode)
#+end_src

* PDF Viewer
PDF Tools is, among other things, a replacement of DocView for PDF files. The
key difference is that pages are not pre-rendered by e.g. ghostscript and
stored in the file-system, but rather created on-demand and stored in memory.

Disable here Swiper for searching, and fallback to Isearch, since Swiper
searchs in the source code rather than in the PDF itself.
#+begin_src elisp
  (use-package pdf-tools
    :demand t
    :config
    (pdf-tools-install)
    :bind (:map pdf-view-mode-map
                ("C-s" . 'isearch-forward)))
#+end_src

Slices are really useful:
- =s r= reset slice.
- =s m= set slice with mouse.
- =s b= set slice using bounding box.

Multiple annotations commands are supported with keybind prefix =C-c C-a= (for
introducing is best to use the mouse for selecting position), and for listing
=C-c C-a l=.

For displaying PDF metadata the command is =I=.

Also, is pretty useful to list all lines containing a phrase (this is called
occur), and can be access using =M-s o=.

* Email Management
Configuration for email within Emacs with =mu4e=. The program mu should be
installed, this program is designed to enable super-efficient handling of
e-mail; searching, reading, replying, moving, deleting. Also Isync should be
installed and configured (this program is the same as mbsync, which is the name
of the isync executable). This program will sync email computer <-> server,
check out my [[file:~/.config/isync/README.org][isync configuration]].

Set =C-c e= as default keybinding for email =mu4e=.
#+begin_src elisp
  (require 'mu4e)
  (setq mail-user-agent 'mu4e-user-agent)
  (global-set-key (kbd "C-c e") 'mu4e)
  #+end_src

Customization of header view. I don't use mailing lists that often, so I have
remove them from headers view.
#+begin_src elisp
  (setq mu4e-headers-fields '( (:from-or-to . 16)
                               (:maildir . 18)
                               (:subject)))
#+end_src

Configure ~mu4e~ to display the buffer in the same window (do not force
full-screen window as the default).
#+begin_src elisp
  (add-to-list 'display-buffer-alist
               `(,(regexp-quote mu4e-main-buffer-name)
                 display-buffer-same-window))
#+end_src

Sort emails in ascending direction.  That means, oldest at top.
#+begin_src elisp
  (setq mu4e-search-sort-direction 'ascending)
#+end_src

Set custom mailboxes.
#+begin_src elisp
  (setq dalvrosa/mailboxes "personal spam")
  (setq mu4e-get-mail-command
        (concat "mbsync -c ~/.config/isync/mbsyncrc -V " dalvrosa/mailboxes))
#+end_src

Prevent mu4e from permanently deleting trashed items. This snippet was taken
from [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/][this article]]. Namespaced and added functionality to mark deleted item as
read.
#+begin_src elisp
  (defun dalvrosa/remove-nth-element (nth list)
    (if (zerop nth) (cdr list)
      (let ((last (nthcdr (1- nth) list)))
        (setcdr last (cddr last))
        list)))
  (setq mu4e-marks (dalvrosa/remove-nth-element 5 mu4e-marks))
  (add-to-list 'mu4e-marks
               '(trash
                 :char ("d" . "▼")
                 :prompt "dtrash"
                 :dyn-target (lambda (target msg) (mu4e-get-trash-folder msg))
                 :action (lambda (docid msg target)
                           (mu4e--server-move docid
                                           (mu4e--mark-check-target target) "-N+S-u"))))
#+end_src

Discourage enriched text alternatives and prefer plain text by default
for email.
#+begin_src elisp
  (with-eval-after-load "mm-decode"
    (add-to-list 'mm-discouraged-alternatives "text/html")
    (add-to-list 'mm-discouraged-alternatives "text/richtext")
    (add-to-list 'mm-discouraged-alternatives "multipart/related"))
#+end_src

** Contexts for Multiple Accounts
I am using contexts for handling two different accounts at the same time. When
launching mu4e for the first time don't ask and just pick the first context
(the default).
#+begin_src elisp
  (setq mu4e-context-policy 'pick-first)
#+end_src

First, lets define basic configuration for all accounts (contexts in mu4e
terminology). This is, set maildir, my personal email addresses (used for not
replying to myself) and the behavior for sent messages.
#+begin_src elisp
  (setq mu4e-sent-messages-behavior 'sent)
  (setq smtpmail-stream-type 'starttls)
  (setq smtpmail-smtp-service 587)
  (setq mu4e-change-filenames-when-moving t)
#+end_src

Define some variables depending if I'm at work. I'm using an SSH tunnel to
bypass block in 587 port.
#+begin_src elisp
  (setq dalvrosa/smtp-server "mail.alvarezrosa.com")
  (setq dalvrosa/smtp-port 587)
#+end_src

The SSH tunnel should be started.
#+begin_src shell :tangle no
  ssh -NTfL 1587:localhost:1587 root@alvarezrosa.com
#+end_src

The actual context accounts.
#+begin_src elisp
  (setq mu4e-contexts
        `( ,(make-mu4e-context
             :name "Personal"
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/Personal" (mu4e-message-field msg :maildir))))
             :vars `(
                     (message-signature-file . "~/docs/Signature.txt")
                     (mu4e-inbox-folder . "/Personal/Inbox")
                     (mu4e-sent-folder . "/Personal/Sent")
                     (mu4e-drafts-folder . "/Personal/Drafts")
                     (mu4e-trash-folder . "/Personal/Trash")
                     (mu4e-refile-folder . "/Personal/Archive")
                     (user-mail-address . "david@alvarezrosa.com")
                     (smtpmail-smtp-service . ,dalvrosa/smtp-port)
                     (smtpmail-smtp-server . ,dalvrosa/smtp-server)))
           ,(make-mu4e-context
             :name "Spam"
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/Spam" (mu4e-message-field msg :maildir))))
             :vars `(
                     (message-signature-file . nil)
                     (mu4e-inbox-folder . "/Spam/Inbox")
                     (mu4e-sent-folder . "/Spam/Sent")
                     (mu4e-drafts-folder . "/Spam/Drafts")
                     (mu4e-trash-folder . "/Spam/Trash")
                     (mu4e-refile-folder . "/Spam/Archive")
                     (user-mail-address . "davids@alvarezrosa.com")
                     (smtpmail-smtp-service . ,dalvrosa/smtp-port)
                     (smtpmail-smtp-server . ,dalvrosa/smtp-server)))))
#+end_src

** Bookmarks
Add custom bookmark for all inboxes.
#+begin_src elisp
  (add-to-list 'mu4e-bookmarks
               '(:name "All Inboxes"
                :query "maildir:/Personal/Inbox OR maildir:/Spam/Inbox"
                :key ?i))
#+end_src

** Update and Notification
Redefine update function to always run update command in the background.
#+begin_src elisp
  (defun dalvrosa/mu4e-update-mail-and-index ()
    (interactive)
    (mu4e-update-mail-and-index t))

  (define-key mu4e-main-mode-map (kbd "U") 'dalvrosa/mu4e-update-mail-and-index)
  (define-key mu4e-update-minor-mode-map (kbd "C-c C-u") 'dalvrosa/mu4e-update-mail-and-index)
#+end_src

Let's init mu4e on the background when launching Emacs and set up automatic
email updates every 10 minutes.  Disable minibuffer messages.
#+begin_src elisp
  (mu4e t)
  (setq mu4e-update-interval (* 60 10))
  (setq mu4e-hide-index-messages t)
#+end_src

Use mu4e alert package for displaying unread email in modeline and enable
notifications. This is currently disabled.
#+begin_src elisp :tangle no
  (setq doom-modeline-mu4e t)

  (use-package mu4e-alert
    :config
    (mu4e-alert-enable-mode-line-display)
    (mu4e-alert-enable-notifications))
#+end_src

Disable email numbering in modeline.
#+begin_src elisp
  (mu4e-modeline-mode 0)
  (setq mu4e-modeline-support nil)
#+end_src

** Queued Email
It allows to save the outgoing mail (output tray) to send them later. Useful
when working without an Internet connection, for example. This can be toggled
in mu4e main view with =m=.
#+begin_src elisp
  (setq smtpmail-queue-dir "~/.local/share/mail/Queue/cur")
#+end_src

** Emacs Unified Directory Client
EUDC is the Emacs Unified Directory Client, a common interface to directory
servers and contact information.

Currently supported back-ends are:
- LDAP, Lightweight Directory Access Protocol
- BBDB, Big Brother’s Insidious Database
- macOS Contacts

The main features of the EUDC interface are:
- Queries using a customizable form
- Inline query expansion (for instance you can expand a name to an email
  address in a mail message buffer using a server as an address book)
- Multiple servers can be tried in turn until a match is found for an inline
  query
- Fast minibuffer queries for email addresses and phone numbers
- Interface to BBDB to let you insert server records into your own BBDB
  database (see BBDB in BBDB Manual)
#+begin_src elisp
  (use-package eudc
    :ensure nil
    :after (ldap bbdb org-msg)
    :init (require 'eudc)
    (require 'eudcb-bbdb)
    :bind (:map message-mode-map
                ("<M-tab>" . eudc-expand-inline)
                :map org-msg-edit-mode-map
                ("<M-tab>" . eudc-expand-inline))
    :config
    (eudc-bbdb-set-server "localhost")
    (setq eudc-server-hotlist
          '(("localhost" . bbdb)))
    (bind-key "<M-tab>" 'eudc-expand-inline org-msg-edit-mode-map)
    (setq eudc-inline-expansion-servers 'hotlist))
#+end_src

*** Big Brother’s Insidious Database
BBDB is the Big Brother’s Insidious Database, a package for Emacs originally
written by Jamie Zawinski which provides rolodex-like database functionality
featuring tight integration with the Emacs mail and news readers. It is often
used as an enhanced email address book.
#+begin_src elisp
  (use-package bbdb
    :demand t)
#+end_src

=bbdb-vcard= imports and exports vCards (version 3.0) as defined in RFC 2425
and RFC 2426 to/from The Insidious Big Brother Database (BBDB). Version 2.1
vCards are converted into version 3.0 on import.
#+begin_src elisp
    (use-package bbdb-vcard
      :after bbdb)
#+end_src

** Composition/Sending
Set default send mail function.
#+begin_src elisp
  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src

Configure citation line (the one that says "On 20 April David wrote...") .
#+begin_src elisp
  (setq message-citation-line-function 'message-insert-formatted-citation-line)
  (setq message-citation-line-format "On %a %d %b %Y at %R, %N wrote:")
#+end_src

Kill message buffer after sending a message.
#+begin_src elisp
  (setq message-kill-buffer-on-exit t)
#+end_src

*** Org Mode HTML
This program sends HTML email using Org-mode HTML export. This approximates a
WYSiWYG HTML mail editor from within Emacs, and can be useful for sending
tables, fontified source code, and inline images in email. LaTeX formulas can
be sent using the modern math delimiters such as \(...\) and \[...\], and also
environments of any kind (the only requirement is that the ‘\begin’ statement
appears on a new line, preceded by only whitespace). It's very useful when
dealing with LaTeX formulas to use =C-c C-x C-l= for producing a preview image
of the LaTeX fragment at point and overlay it over the source code (f there is
no fragment at point, process all fragments in the current entry-—between two
headlines).
#+begin_src elisp
  (use-package org-mime
    :config
    (setq org-mime-export-options '(:with-latex dvipng
                                    :section-numbers nil
                                    :with-author nil
                                    :with-toc nil))
    :bind (:map message-mode-map
                (("C-c o" . 'org-mime-edit-mail-in-org-mode)
                 ("C-c M-o" . 'org-mime-htmlize))))
#+end_src

Some useful functions are =org-mime-edit-mail-in-org-mode= (press =C-c o=) for
editing the mail in a special buffer in Org mode, and then =org-mime-htmilize=
(with =C-c M-o=) from within a mail composition buffer to export either the
entire buffer or just the active region to html, and embed the results into the
buffer as a text/html mime section. After =org-mime-htmlize=, you can always
run =org-mime-revert-to-plain-text-mail= restore the original plain text mail.

For embedding image into mail body the syntax is as follows:
=[[/full/path/to/your.jpg]]=.

The function =org-mime-org-buffer-htmlize= can be called from an Org mode
buffer to export either he whole buffer or the narrowed subtree or active
region to HTML, and open a new email buffer including the resulting HTML
content as an embedded mime section.

The function =org-mime-org-subtree-htmlize= is similar to
=org-mime-org-buffer-htmlize= but works on subtree. It can also read subtree
properties MAIL_SUBJECT, MAIL_TO, MAIL_CC, and MAIL_BCC. Here is the sample of
subtree:
#+begin_example
  ,* mail one
   :PROPERTIES:
   :MAIL_SUBJECT: mail title
   :MAIL_TO: person1@gmail.com
   :MAIL_CC: person2@gmail.com
   :MAIL_BCC: person3@gmail.com
   :END:
  some text here ...
#+end_example

*** Org Msg
*Not tangled.*  Configure Org Msg that automatically writes HTML emails when needed.
#+begin_src elisp :tangle no
  (use-package org-msg
    :after (mu4e)
    :init (org-msg-mode)
    :config
    (setq
     org-msg-options "html-postamble:nil num:nil ^:{} toc:nil author:nil email:nil tex:dvipng"
     org-msg-default-alternatives '((new . (text))
                                    (reply-to-html . (text html))
                                    (reply-to-text . (text)))
     org-msg-convert-citation t)
    ;; https://github.com/jeremy-compostella/org-msg/pull/152
    (setq mu4e-compose-signature-auto-include nil)
    (advice-add 'org-msg-composition-parameters :before 'dalvrosa/set-org-msg-signature))

  (defun dalvrosa/set-org-msg-signature (type alternatives)
    (if message-signature-file
        (setq org-msg-signature (f-read-text message-signature-file))
      (setq org-msg-signature nil)))
#+end_src

** Attachment Management
Configure attachment directory for downloading.
#+begin_src elisp
  (setq mu4e-attachment-dir "~/tmp")
#+end_src

For attaching files while composing new email. To attach file, just mark in
dired and =C-c RET C-a=. This is useful for attaching multiple files, but the
default =C-c C-a= command for attaching (in composition buffer) works just
well.
#+begin_src elisp
  (require 'gnus-dired)
  (defun gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+end_src

** Meetings
Allow reply to iCalendar emails (i.e. accept, decline or tentatively accept
meetings).
#+begin_src elisp
  (require 'mu4e-icalendar)
  (mu4e-icalendar-setup)
  (setq mu4e-icalendar-trash-after-reply t)
  #+end_src

Capture meetings and display them in org-agenda.
#+begin_src elisp
  (setq gnus-icalendar-org-capture-file "~/docs/Agenda.org")
  (setq gnus-icalendar-org-capture-headline '("Calendar"))
  (gnus-icalendar-org-setup)
#+end_src

* Web Feed Reader
Elfeed is an extensible web feed reader for Emacs, supporting both Atom and
RSS. It requires Emacs 24.3.
#+begin_src elisp
  (use-package elfeed
    :bind (("C-c f" . 'elfeed)
           :map elfeed-search-mode-map (("v" . 'dalvrosa/elfeed-play-with-mpv)
                                        ("i" . 'dalvrosa/elfeed-ignore)))
    :config (setq elfeed-db-directory "~/.config/emacs/elfeed"
                  elfeed-search-filter "@1.5-week-ago -no "
                  elfeed-sort-order 'ascending
                  elfeed-search-title-max-width 100))
#+end_src

** Elfeed Org
Use Elfeed Org for managing subscriptions to RSS/Atom feeds using an org mode
file.
#+begin_src elisp
  (use-package elfeed-org
    :after elfeed
    :init (elfeed-org)
    :config (setq rmh-elfeed-org-files (list "~/docs/Subscriptions.org")))
#+end_src

** Custom Functions
For interacting with video (e.g., Youtube subscriptions). This allows to open
the media with mpv. Just press =v= and the video will be openend with mpv.
#+begin_src elisp
  (defun dalvrosa/elfeed-play-with-mpv ()
    (interactive)
    (setq url (elfeed-entry-link (elfeed-search-selected :single)))
    (start-process "elfeed-mpv" nil "mpv" "--ytdl-format=[height<=720]" url)
    (elfeed-search-untag-all-unread))
#+end_src

Ignore current entry (i.e., tag it with =no= TAG).
#+begin_src elisp
  (defun dalvrosa/elfeed-ignore ()
    (interactive)
    (setq entry (elfeed-search-selected :single))
    (setq tag (intern "no"))
    (elfeed-tag entry tag)
    (elfeed-search-update-entry entry)
    (forward-line))
#+end_src

* Internet Relay Chat (IRC)
IRC is a text-based chat system. It enables discussions among any number of
participants in so-called conversation channels, as well as discussions between
only two partners--for example, in question-and-answer dialogues. This protocol
is actually older than the World Wide Web. There are several built-in Emacs IRC
clients, but I use the default ERC, that I think is the best one. I have bind
the ERC client, with TLS support, to =C-c i= ("i" for IRC).
#+begin_src elisp
  (global-set-key (kbd "C-c i") 'erc-tls)

  (setq erc-server "irc.alvarezrosa.com")
  (setq erc-nick "dalvrosa")
  (setq erc-user-full-name "David Álvarez Rosa")
  (setq erc-prompt-for-password nil)
  (setq erc-hide-list '("JOIN" "PART" "QUIT"))
#+end_src

If you are an IRC user, you may find me out there. I usually hang out in
libera.chat these days (after the freenode management debacle) with the
=dalvrosa= nick.

I have configured the authentication file (see [[*Authentication File][Authentication File]]) with
password information so I don't need to enter it every time. I am actually
connecting to a personal IRC Bouncer (ZNC) hosted in my personal VPS at
irc.alvarezrosa.com, so I do most of the configuration there. The line added to
this file looks as follows:
#+begin_src conf :tangle no
  machine irc.alvarezrosa.com port 6697 login dalvrosa password david:***pass***
  machine localhost port 6697 login dalvrosa password david:***pass***
#+end_src

I'm using SSH tunneling to bypass port 6697 block. This can be done with the
following command.
#+begin_src shell :tangle no
  ssh -NTfL 6697:localhost:6697 root@alvarezrosa.com
#+end_src

After quiting server, query or parting a channel I want the buffer to be killed
automatically.
#+begin_src elisp
  (setq erc-kill-buffer-on-part t)
  (setq erc-kill-queries-on-quit t)
  (setq erc-kill-server-buffer-on-quit t)
#+end_src

Some minor tweaks for displaying (and buffer) configuration.
#+begin_src elisp
  (setq erc-fill-function 'erc-fill-static)
  (setq erc-fill-static-center 22)
  (setq erc-rename-buffers t)
#+end_src

I use ERC channel tracking (it is enabled by default). Basically, show in the
modeline unread chat messages from current openend channels and use =C-c C-SPC=
repeatedly for switching between them (in *any* mode).
#+begin_src elisp
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE" "AWAY"))
  (setq erc-track-exclude-server-buffer t)
#+end_src

** Nickname Highlighter
This package will auto colorize (highglight) nicknames, ignoring certain
characters that IRC clients add to nicknames to avoid duplicates (nickname,
nickname’, nickname”, etc.)
#+begin_src elisp
  (use-package erc-hl-nicks)
#+end_src

* Useful Resources
- [[https://github.com/daedreth/UncleDavesEmacs][Dawid Eckert]] has a Youtube channel with nice Emacs tutorials (is called
  UncleDave).
- [[https://github.com/mxco86/emacs-config/blob/master/.emacs.d/emacs.org][Matthew Ryall]]
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org][David Wilson]] is the owner of SystemCrafters channel.
- [[https://github.com/munen/emacs.d][Alain M. Lafon]] is the author of "Play Emacs like an instrument" video, and
  has a very neat configuration.
- [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/prot-emacs.org][Protesilaos Stavrou]] this guy is amazing, he also has a youtube channel.
- [[https://github.com/bradwright/emacs.d][Bradley Wright]]
- [[https://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua ]]she is a well known Emacs blogger.
- [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]] is a community driven list of useful Emacs packages, utilities
  and libraries
- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] has an amazing Org mode configuration called "Organize Your Life
  In Plain Text!" and it's probably the most complete configuration out there.
- [[https://github.com/SirPscl/emacs.d][Pascal Huber]] another nice Emacs configuration to take into account.
- [[https://cestlaz.github.io/stories/emacs/][Mike Zamansky]] a well known Emacs guru, that has a blog called "C'est la Z"
  with a nice Emacs series (+75 blog entries, each one of them with video).
- [[https://github.com/rememberYou/.emacs.d/blob/master/config.org/][Terencio Agozzino]] is a computer engineer with a very nice (literate) Emacs
  configuration. He has written in Reddit (as =u/rmberYou/=) several Emacs
  tips that are worth checking out.
