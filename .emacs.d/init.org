#+TITLE: GNU Emacs Configuration
#+LANGUAGE: en
#+AUTHOR: David Álvarez Rosa
#+EMAIL: david@alvarezrosa.com
#+DESCRIPTION: My personal GNU Emacs configuration file.
#+PROPERTY: header-args :tangle yes


GNU Emacs is a free (as in /freedom/) +operating system+ text editor, created
by GNU Project founder Richard Matthew Stallman. I've been using this
magnificent piece of software daily for years now and I can assure you that
is--without a doubt--the best multi-purpose program ever written,
over-performing any other so-called text editors, such as Vi(m)--the editor of
the beast-- or, even worse, Microsoft VS Code malware, among others. I consider
myself a member of the Church of Emacs, my only religion, and I'm a firmly
believer in St. I-GNU-cius--who is a saint, but not a virgin--and to whom I
pray daily. In my day-to-day life I try to stick to the FOSS philosophy, while
living a life of moral chastity and purity, pursuing sainthood mainly through
extensively using org-mode.

There are some people out there that don't really get the meaning and purpose
of Emacs. They think that it is just another bloated text editor that doesn't
adhere to the KISS principle or the Unix philosophy. It is not. First, it is
not a text editor, it is a Lisp interpreter (actually, Elisp), a
Turing-complete programming language (therefore, offering limitless
possibilities). Secondly, there is no contradiction between using Emacs and
KISS or Unix philosophy: Emacs--at least for me--is a container for
"do-one-thing-and-do-it-well" packages that behave similarly, I find no
conflict here. Lastly, Emacs is a gift from God.


* Table of Contents                                                     :TOC:
- [[#preamble][Preamble]]
  - [[#installation][Installation]]
  - [[#about-this-configuration][About this Configuration]]
  - [[#license-and-copyright][License and Copyright]]
- [[#loading-and-package-management][Loading and Package Management]]
- [[#general-configuration][General Configuration]]
  - [[#personal-information][Personal Information]]
  - [[#server-mode][Server Mode]]
  - [[#custom-file][Custom File]]
  - [[#change-yesno-questions-to-yn][Change yes/no Questions to y/n]]
  - [[#file-management][File Management]]
  - [[#buffer-management][Buffer Management]]
  - [[#window-management][Window Management]]
  - [[#auto-fill-mode][Auto Fill Mode]]
  - [[#subword-mode][Subword Mode]]
  - [[#region-selection][Region Selection]]
  - [[#scrolling-and-point-location][Scrolling and Point Location]]
  - [[#character-pairs][Character Pairs]]
  - [[#html-renderer][HTML Renderer]]
  - [[#completion-inteface][Completion Inteface]]
  - [[#spell-checking-and-correcting][Spell Checking and Correcting]]
- [[#user-interface][User Interface]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#font][Font]]
  - [[#basic-interface-settings][Basic Interface Settings]]
  - [[#transparency-alpha][Transparency Alpha]]
- [[#programming-configuration][Programming Configuration]]
  - [[#general-configuration-1][General Configuration]]
  - [[#cc][C/C++]]
  - [[#python][Python]]
  - [[#web-development][Web Development]]
  - [[#octavematlab][Octave/Matlab]]
  - [[#r][R]]
- [[#org-mode][Org Mode]]
  - [[#list-configuration][List Configuration]]
  - [[#indent-mode][Indent Mode]]
  - [[#speed-commands][Speed Commands]]
  - [[#refile][Refile]]
  - [[#capture-templates][Capture templates]]
  - [[#state-keywords][State Keywords]]
  - [[#code-evaluation][Code Evaluation]]
  - [[#interface][Interface]]
  - [[#agenda][Agenda]]
  - [[#archive][Archive]]
  - [[#table-of-contents][Table of Contents]]
- [[#edición-de-documentos][Edición de documentos]]
  - [[#markdown-mode][Markdown Mode]]
  - [[#latex][LaTeX]]
- [[#pdf-viewer][PDF Viewer]]
- [[#email-management][Email Management]]
  - [[#contexts-for-multiple-accounts][Contexts for Multiple Accounts]]
  - [[#queued-email][Queued Email]]
  - [[#signing-and-encryption][Signing and Encryption]]
  - [[#completion][Completion]]
  - [[#compositionsending][Composition/Sending]]
  - [[#attachment-management][Attachment Management]]
- [[#music-player][Music Player]]
- [[#web-feed-reader][Web Feed Reader]]
  - [[#elfeed-org][Elfeed Org]]
  - [[#elfeed-goodies][Elfeed Goodies]]
  - [[#custom-functions][Custom Functions]]
- [[#internet-relay-chat-irc][Internet Relay Chat (IRC)]]
- [[#useful-resources][Useful Resources]]

* Preamble
** TODO Installation
** About this Configuration
Underlying principles:
- Built-in alternatives have been preferred to standalone (M)ELPA packages.
- User define commands are usually bound with =C-c= prefix, to avoid clashing
  with Emacs defaults (that usually use =C-x=).
- Minimalist, yet powerful.

Some utilities:
- Email Management, with mu4e and bound to =C-c e= ("e" for email).
- Web Feed Reader, with Elfeed. Bound to =C-c f= ("f" for feed).
- Org mode Agenda, bound to =C-c a= ("a" for agenda).
- Music Management, bound to =C-c m= ("m" for music).
- IRC client, with ERC. Bound to =C-c i= ("i" for IRC).
- Trasparency alpha toggler. Bound to =C-c t= ("t" for transparency).
- Light/Dark theme. Bound to =C-c d= ("d" for dark) and =C-c l= ("l" for
  light).
- Git, with Magit, bound to =C-c g= ("g" for git).
- Kill all buffers except current and *scratch*. Bound to =C-c k= ("k" for
  killing). This is kind of "restaring" Emacs session without actually closing
  it.

Conventions:
- Functions and variables defined by me are prefixed with my name and a slash,
  i.e., =david/= to namespace them and avoid conflicts.

** License and Copyright
Copyright 2021 David Álvarez Rosa.

Files are licensed under the same license as Emacs (GPL) unless otherwise
specified. See the LICENSE file for more information.

Any external/third party works included in this work are licensed under their
own licenses--refer to the submodules or packages for more information.

* Loading and Package Management
Make startup faster by reducing the frequency of garbage collection and then
use a hook to lower threshold back after Emacs startup. The loading time can be
check with the function =emacs-init-time=.
#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum)

  ;; Lower threshold back to 8 MiB (default is 800kB)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (expt 2 23))))
#+end_src

Add MELPA package repositories.
#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
#+end_src

=use-package= will be used for general package management. Ensure it is
installed and load the package.
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+end_src

Always ensure that all package are installed when starting Emacs. If a
particular package does not exist, it will be installed automagically.
#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

* General Configuration
This section contains all configuration related to main settings for built-in
Emacs features.

** Personal Information
Basic personal information (name and mail address). Email variable will be
changed accordingly when using =mu4e= contexts (see configuration below).
#+begin_src emacs-lisp
  (setq user-full-name "David Álvarez Rosa")
  (setq user-mail-address "david@alvarezrosa.com")
#+end_src

** Server Mode
Start the Emacs server mode from this instance, so that all =emacsclient= calls
are routed here. This way, files can be sent to the current Emacs instance,
instead of opening a new one (much faster).
#+begin_src emacs-lisp
  (server-start)
#+end_src

** Custom File
Place all custom-defined variables in their own file and store the custom
variable file in the local machine’s home directory outside of version
control. This enables us to keep specific config local to each machine.
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file t)
#+end_src

** Change yes/no Questions to y/n
Shorter and faster.
#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** File Management
Configuration related to file management.

*** Dired Mode
Dired is the main mode for Emacs file-manager operations. The name “Dired”
stands for “directory editor”.

Dired buffer can be modified by making them editable presing =C-x C-q=. With
this is posible to bulk-rename files, or to change file ownerships and
privileges, just thinking about the file listing as an (Emacs) editable text
file.

Show file sizes in a human readable style.
#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-alh")
#+end_src

Ability to use =a= to visit a new directory or file in Dired instead of using
=RET=. =RET= works just fine, but it will create a new buffer for every
interaction whereas =a= reuses the current buffer.
#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

**** Dired Narrow
This package provides live filtering of files in dired buffers. In general,
after calling the respective narrowing function you type a filter string into
the minibuffer. With =/= start fuzzy matching, then use the dired buffer as
usual, and =g= for going back to the complete file listing.
#+begin_src emacs-lisp
  (use-package dired-narrow
    :bind (:map dired-mode-map
                ("/" . 'dired-narrow-fuzzy)))
#+end_src

*** File Backups and Autosaves
Keep backups and autosaves in the "temp" directory. Take into account that this
is a dangerous option with respect the disappearance of files, but I always use
version control for important projects, so that is not a problem for me.
#+begin_src emacs-lisp
  (setq backup-directory-alist
        `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
        `((".*" ,temporary-file-directory t)))
#+end_src

** Buffer Management
Buffers, in Emacs terminology, hold the contents that display/edit in
windows. This are the configurations I use.

*** Ibuffer Mode
Ibuffer is an advanced replacement for BufferMenu, which lets you operate on
buffers much in the same manner as Dired. The most important Ibuffer features
are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Start in expert mode (without asking for confirmation).
#+begin_src emacs-lisp
  (setq ibuffer-expert t)
#+end_src

Kill current buffer without asking for which buffer to kill.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+end_src

*** Kill All Function
Kill all buffers except current and *scratch*. Useful for "restarting" Emacs
without closing it.
#+begin_src emacs-lisp
  (defun david/kill-all-other-buffers ()
    "Kill all buffers except current and *scratch*."
    (interactive)
    (delete-other-windows)
    (setq scratch (get-buffer "*scratch*"))
    (mapc 'kill-buffer (delq scratch (delq (current-buffer) (buffer-list)))))
  (global-set-key (kbd "C-c k") 'david/kill-all-other-buffers)
#+end_src

*** Narrowing
Narrowing buffers is very useful, however this commands are disabled by default
because new users often find them confusing. However, this configuration is
*not* for newbies, so enable them.
#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'narrow-to-page 'disabled nil)
  (put 'LaTeX-narrow-to-environment 'disabled nil)
#+end_src

I use =C-x n n= for narrowing to region and then =C-x n w= for widen (i.e.,
reverting to full page), but there are more narrow functions (enviroment
dependent), e.g., =C-x n d= for narrowing to defun (useful for narrowing
functions).

** Window Management
Split and follow for creating new windows.
#+begin_src emacs-lisp
  (defun david/split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'david/split-and-follow-horizontally)

  (defun david/split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'david/split-and-follow-vertically)
#+end_src

New bind for killing buffer *and* window at the same time. To do this press
=C-x C-k=, by default is bind to =C-x 4 0=, that is far more complex.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-k") 'kill-buffer-and-window)
#+end_src

*** Wind Move
Is built into Emacs (since version 21). It lets you move point from window to
window using =Shift= and the arrow keys. This is easier to type than =C-x o=
and, for some users, may be more intuitive.
#+begin_src emacs-lisp
  (windmove-default-keybindings)
#+end_src

Also set up keybinding for directional window swap states. Keys are bound to
commands that swap the states of the selected window with the window in the
specified direction.
#+begin_src emacs-lisp
  (windmove-swap-states-default-keybindings '(super meta))
#+end_src

I am setting the modifier keys for swaping to =super-meta= because the default
=shift-super= are already bound by my i3 (window manager) configuration.

*** Winner Mode
Global minor mode that allows to “undo” and “redo” changes in window
configuration. It is included in GNU Emacs.
#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

*** Ace Window
Package for selecting a window to switch to. What it does is: when there are
two windows, Ace Window will call =other-window=. If there are more, each
window will have the first character of its window label highlighted at the
upper left of the window. Pressing that character will either switch to that
window or filter to the next character needed to select a specific window.
#+begin_src emacs-lisp
  (use-package ace-window
    :bind ("M-o" . 'ace-window))
#+end_src

Some useful features, is the posibility to swap windows, by calling
=ace-window= with a prefix argument, i.e., =C-u=. And is also posbile to delete
the selected window by prefixing double, i.e., with =C-u C-u=.

You can also start by calling ace-window and then decide to switch the action
to =delete= or =swap= etc. There are a bunch of command here (check them with
=?= when =ace-window= is activated), but the ones I use the most are:
- Delete window with =x=.
- Swap windows with =m= ("m" from move).

** Auto Fill Mode
Long lines are a bad practice. Please, don't use them, I find them quite
annoying. Stick to at most 80 characters. Use =M-q= for filling paragraphs when
editing (i.e., always ensure the =fill-column= limit).
#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
  (setq-default fill-column 79)
#+end_src

I don't type double-space sentences, I end sentences just with a single space.
This is relevant for filling.
#+begin_src emacs-lisp
  (setq-default sentence-end-double-space nil)
#+end_src

** Subword Mode
Emacs treats camelCase strings as a single word by default, change this
behaviour.
#+begin_src emacs-lisp
  (global-subword-mode 1)
#+end_src

** Region Selection
In Emacs terminology the region is the selected portion of the text.

Real Emacs knights don't use shift to mark things, so disable it.
#+begin_src emacs-lisp
  (setq shift-select-mode nil)
#+end_src

Set delete selection mode, so typed text replaces the selection if the
selection is active. Otherwise, typed text is just inserted at point regardless
of any selection.
#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

*** Expand Region
Expand region increases the selected region by semantic units. Just keep
pressing the key until it selects what you want. Expand region is done by
pressing ~C-=~ and contracting by prefixing the shortcut with a negative
argument argument, i.e., ~C-- C-=~.
#+begin_src emacs-lisp
  (use-package expand-region
    :bind ("C-=" . 'er/expand-region))
#+end_src

*** Upcase/Downcase Region
Command for upcasing =C-x C-u= or downcasing =C-x C-l= current region are also
disabled by default, enable them.
#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

** Scrolling and Point Location
I personally don't like automatic scrolling (centering point vertically in the
window when point moves out of the visible portion of the text) so I have it
disabled (just set the following number to a large number, greater than 100).
#+begin_src emacs-lisp
  (setq scroll-conservatively 101)
#+end_src

Set keys for forward/backward between paragraphs (this is similar to =C-f= vs
=M-f=) .
#+begin_src emacs-lisp
  (define-key global-map (kbd "M-n") 'forward-paragraph)
  (define-key global-map (kbd "M-p") 'backward-paragraph)
#+end_src

Scroll window pane with keyboard, but without changing cursor line.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-n") 'scroll-up-line)
  (global-set-key (kbd "C-M-p") 'scroll-down-line)
#+end_src

Controls if scroll commands move point to keep its screen position unchanged. A
value of t means point keeps its screen position if the scroll command moved it
vertically out of the window, e.g. when scrolling by full screens.
#+begin_src emacs-lisp
  (setq scroll-preserve-screen-position t)
#+end_src

With =C-x C-n= Use the current column of point as the semipermanent goal column
for =C-n= and =C-p= in the current buffer. When a semipermanent goal column is
in effect, those commands always try to move to this column, or as close as
possible to it, after moving vertically. The goal column remains in effect
until canceled (with =C-u C-x C-n=). This command is disabled by default, I
enable it.
#+begin_src emacs-lisp
  (put 'set-goal-column 'disabled nil)
#+end_src

Right and left scrolling commands are trigered with =C-c >= and =C-c <=
respectively. Scroll left is disabled by default, I enable it.
#+begin_src emacs-lisp
  (put 'scroll-left 'disabled nil)
#+end_src

Two very useful commands for recentering window are =C-l= and =C-M-l=, the
former is a well-known Emacs command, and the latter is for =reposition-window=
function, that makes the current definition and/or comment visible (i.e., it
attempts to scroll the window so the maximum content is visible).

*** Avy
Package for jumping to visible text using a char-based decision tree. I use
both =C-:= for jumping to the currently visible CHAR1 followed by CHAR2 (i.e.,
jump to a sequence of 2 chars in any window/frame) and =M-g w= for jumping to
the currently visible CHAR at a word start.
#+begin_src emacs-lisp
  (use-package avy
    :bind (("C-:" . 'avy-goto-char-2)
           ("M-g w" . 'avy-goto-word-1)))
#+end_src

** Character Pairs
It can be useful to insert parentheses, braces, quotes and the like in matching
pairs, e.g., pressing “(” inserts "()", with the cursor in between.
#+begin_src emacs-lisp
  (electric-pair-mode t)
#+end_src

Highlight matching braces.
#+begin_src emacs-lisp
  (show-paren-mode 1)
#+end_src

** HTML Renderer
Configure shr HTML render engine for converting HTML to text. I like the HTML
to be converted to text, without fancy fonts, and filled to 72 characters.
#+begin_src emacs-lisp
  (setq shr-use-fonts nil)
  (setq shr-width 72)
#+end_src

** Completion Inteface
After years using Helm I have decided to switch to Ivy, Counsel and Swiper as
completion framework.

Ivy is the generic completion mechanism for Emacs and aims to be more
efficient, smaller, simpler, and smoother to use compared to other completion
schemes yet highly customizable.
#+begin_src emacs-lisp
  (use-package ivy
    :init (ivy-mode)
    :config
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-count-format "%d/%d ")
    (setq ivy-initial-inputs-alist nil))
#+end_src

This package comes with rich transformers for commands from ivy and counsel,
makes the completion interface more friendly (showing more information).
#+begin_src emacs-lisp
  (use-package ivy-rich
    :init (ivy-rich-mode 1))
#+end_src

Counsel is a collection of Ivy-enhanced versions of common Emacs commands, i.e,
takes Ivy completion framework even further providing versions of common Emacs
commands that are customised to make the best use of Ivy.
#+begin_src emacs-lisp
  (use-package counsel
    :init (counsel-mode))
#+end_src

Swiper is an alternative to isearch that uses Ivy to show an overview of all
matches.
#+begin_src emacs-lisp
  (use-package swiper
    :bind ("C-s" . 'swiper))
#+end_src

Some useful commands for the Ivy/Counsel/Swiper framework that I use are =M-i=
for inserting current candidate to minibuffer and =C-r= for recursive
completion session through the command's history (works like in a Bash
session). Also =M-o= for showing all the possible options/actions and =S-SPC=
for deleting the current input, and reseting the candidates list to the
currently restricted matches (narrowing search). To open the search results in
a separate buffer, press =C-c C-o= for occur.

*** Keybinding Panel
Nice utility (=which-key=) for displaying available keybindings in a popup
panel. You get an overview of what keybindings are available based on the
prefix keys you entered.
#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode))
#+end_src

** Spell Checking and Correcting
Commands to check the spelling of a single word or of a portion of a buffer.
These commands only work if a spelling checker program, one of Hunspell,
Aspell, Ispell or Enchant, is installed. These programs are not part of Emacs,
but one of them is usually installed on GNU/Linux and other free operating
systems. I have installed Aspell with =pacman -S aspell aspell-es aspell-en=
(for isntalling english and spanish dictionaries).

I set the default dictionary to english, since I write more in english than in
spanish these days. This can be changed with =ispell-change-dictionary=
function.
#+begin_src emacs-lisp
  (setq ispell-dictionary "english")
#+end_src

Main command for spell checking is =M-$= for check and correct pelling of the
word at point, but if the region is active, do it for all words in the region
instead. When this command encounters what appears to be an incorrect word, it
asks you what to do, here are some valid responses (see them all with =?=):
- =digit= for replacing the word.
- =SPC= for skipping this word, and continue.
- =r= replace the word with some user-defined string.
- =a= accept the word only in this editing session (there is =A= variant, for
  only in this buffer).
- =i= insert word to personal dictionary (there is =u= variant, for inserting
  the lowercase version of that word in the dictionary).

It is also useful the use spelling *on the fly* with =flyspell-mode=, that
highlights all misspelled words (the variant =flyspell-prog-mode= is for
programming language, where spelling should occur only for comments and
strings).

* User Interface
Settings related to the user interface, such as the theme, the modeline, the
font, other basic interface settings, and the transparency alpha.

** Theme
I am using Doom Themes. I find creating own theme is too much work and it's now
worth your time. In the past I used Spacemacs theme and I was nice, but I
became bored of it. Doom Themes provides nice themes such as =doom-one= (dark),
=doom-one-ligth= (light), and the classic =zenburn= of course.
#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme 'doom-one-light t)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

Some themes I also like are =doom-peacock= (dark) and =doom-tomorrow-day=
(light).

Custom keybindings for switching between ligth and dark themes in
Emacs. Currently =C-c l= sets ligths theme (i.e., doom-one-light) and =C-c d=
sets dark theme (i.e., doom-one).
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c d") (lambda () (interactive) (load-theme 'doom-one t)))
  (global-set-key (kbd "C-c l") (lambda () (interactive) (load-theme 'doom-one-light t)))
#+end_src

Consider all custom themes as safe (don't ask for confirmation when loading
it).
#+begin_src emacs-lisp
  (setq custom-safe-themes t)
#+end_src

** Modeline
For the modeline I am using also Doom Modeline. This package requires the fonts
included with =all-the-icons= to be installed. I have configured it to show
column number instead of percentage buffer position.
#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :config (setq column-number-mode t)
    (setq doom-modeline-percent-position nil))
#+end_src

** Font
Set default font. I'm currently using Hack (in the past I used Inconsolata).
#+begin_src emacs-lisp
  (set-frame-font "Hack 9")
#+end_src

** Basic Interface Settings
Settings related to built-in enhancements of the UI that do not depend on any
external package.

*** Disable Menus and Scrollbars
Disable tool bar, menu bar and scroll bar. All three are very ugly and
unnecesary. Might be handy for normies, but not for chad Emacs users.
#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
#+end_src

*** Remove Startup Screen
Inhibit lame startup screen.
#+begin_src emacs-lisp
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-message t)
#+end_src

*** Highlight Cuurrent Line
Pretty nice UI enhancement for finding current line. It does not look good in
the terminal version of Emacs, though, so it's not set there.
#+begin_src emacs-lisp
  (when window-system (global-hl-line-mode t))
#+end_src

** Transparency Alpha
Functions for toggling transparency alpha.
#+begin_src emacs-lisp
  (set-frame-parameter nil 'alpha '(95 . 90))
  (defun david/toggle-transparency ()
    "Toggle transparency on and off."
    (interactive)
    (let ((alpha (frame-parameter nil 'alpha)))
      (if (eq
           (if (numberp alpha)
               alpha
             (cdr alpha)) ; may also be nil
           100)
          (set-frame-parameter nil 'alpha '(95 . 90))
        (set-frame-parameter nil 'alpha '(100 . 100)))))
  (define-key global-map (kbd "C-c t") 'david/toggle-transparency)
#+end_src

* Programming Configuration
Configuration settings related to programming languages.

** General Configuration
Programming configuration that is not specific to one programming language.
*** Code Completion
Company is a text/code completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to retrieve and
display completion candidates.
#+begin_src emacs-lisp
  (use-package company
    :config (setq company-show-quick-access t)
    :hook (prog-mode . company-mode))
#+end_src

Completion will start automatically after you type a few letters. Use =C-n= and
=C-p= to select, =RET= to complete or =TAB= to complete the common part. Search
through the completions with =C-s=, =C-r= and =C-o=. Press =M-(digit)= to
quickly complete with one of the first 10 candidates.

When the completion candidates are shown, press =<f1>= to display the
documentation for the selected candidate, or =C-w= to see its source.

*** Line Numbers
Display line numbers.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

*** Tabs vs Spaces
A good programmer knows that spaces are by far a better alternative than tabs.
This doesn't mean you need to insert the spaces manually. Emacs will take care
of this for you.

Configure default tab width to 4 spaces.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Ensure spaces are entered when pressing the =TAB= key.
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** Trailing Whitespace
Delete (nasty) trailing whitespace when saving a file (this includes emtpy
lines at the end of the file and empty spaces at the end of lines).
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** TODO Corrección de sintaxis
Habilitar corrección de sintaxis al momento usando =flycheck=
(http://www.flycheck.org/).
#+begin_src emacs-lisp :tangle no
  (use-package flycheck
    :init
    (add-hook 'prog-mode-hook 'global-flycheck-mode))
#+end_src

*** Projectile
Projectile is a project interaction library for Emacs. Its goal is to provide a
nice set of features operating on a project level without introducing external
dependencies (when feasible). It is very nice, because it integrates seamlessly
with version control (like Git) and takes into account =.gitignore= files.
#+begin_src emacs-lisp
  (use-package projectile
    :config (projectile-mode +1)
    :bind (:map projectile-mode-map ("C-c p" . 'projectile-command-map)))
#+end_src

Some of the projectile features:
- Jump to a file in project
- Jump to files at point in project
- Jump to a directory in project
- Jump to a file in a directory
- Jump to a project buffer
- Jump to a test in project
- Toggle between files with same names but different extensions (e.g. .h <->
  .c/.cpp, Gemfile <-> Gemfile.lock)
- Toggle between code and its test (e.g. main.service.js <->
  main.service.spec.js)
- Jump to recently visited files in the project
- Switch between projects you have worked on
- Kill all project buffers
- Replace in project
- Multi-occur in project buffers
- Grep in project
- Regenerate project etags or gtags (requires ggtags).
- Visit project in dired
- Run make in a project with a single key chord
- Check for dirty repositories
- Toggle read-only mode for the entire project

*** Magit
Magit is one of the killer features in Emacs, is a complete text-based user
interface to Git. It fills the glaring gap between the Git command-line
interface and various GUIs, letting you perform trivial as well as elaborate
version control tasks with just a couple of mnemonic key presses. Magit looks
like a prettified version of what you get after running a few Git commands but
in Magit every bit of visible information is also actionable to an extent that
goes far beyond what any Git GUI provides and it takes care of automatically
refreshing this output when it becomes outdated. In the background Magit just
runs Git commands and if you wish you can see what exactly is being run, making
it possible for you to learn the git command-line by using Magit.
#+begin_src emacs-lisp
  (use-package magit
    :bind ("C-c g" . 'magit-status))
#+end_src

Using Magit for a while will make you a more effective version control user.
Magit supports and streamlines the use of Git features that most users and
developers of other Git clients apparently thought could not be reasonably
mapped to a non-command-line interface. Magit is both faster and more intuitive
than either the command line or any GUI and these holds for both Git beginners
and experts alike.

*** Snippets
YASnippets is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function templates.
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-reload-all)
    :hook (prog-mode . yas-minor-mode))
#+end_src

*** Ediff
Ediff provides a convenient way for simultaneous browsing through the
differences between a pair (or a triple) of files or buffers. The files being
compared, are shown in separate windows and the differences are highlighted as
you step through them. You can also copy difference regions from one buffer to
another (and recover old differences if you change your mind). Another powerful
feature is the ability to merge a pair of files into a third buffer.

Don't open new frame for setup window and prefer splitting horizontally.
#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

** C/C++
Configuration for C/C++ programming languages.

*** Header Completion
This library enables the completion of C/C++ header file names using Company
mode for Emacs.
#+begin_src emacs-lisp
  (use-package company-c-headers
    :config
    (add-to-list 'company-backends 'company-c-headers))
#+end_src

** Python
Elpy is the Emacs Python Development Environment. It aims to provide an easy to
install, fully-featured environment for Python development.
#+begin_src emacs-lisp
  (use-package elpy
    :init
    (elpy-enable))
#+end_src

Once installed, Elpy will automatically provide code completion, syntax error
highlighting and code hinting (in the modeline) for python files. Elpy offers a
lot of features, but the following keybindings should be enough to get started:
- =C-c C-c= evaluates the current python script (or region if something is
selected) in an interactive python shell. The python shell is automatically
displayed aside of your script.
- =C-RET= evaluates the current statement (current line plus the following
  nested lines).
- =C-c C-z= switches between your script and the interactive shell.
- =C-c C-d= displays documentation for the thing under cursor. The documentation
  will pop in a different buffer, that can be closed with q.

Moving around and indenting is similar to Org mode.

Some more things that are pretty sweet.
- =M-.= go to definition.
- =M-*= go back from definition where I was.
- =C-c C-o= occur definition. All places where a function/class is used.

** Web Development
Web mode is an autonomous emacs major-mode for editing web templates. HTML
documents can embed parts (CSS/JavaScript) and blocks (client/server side).
#+begin_src emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (setq web-mode-markup-indent-offset 2))
#+end_src

Some useful commands:
- Jumping with =C-c C-n= between opening/closing HTML tags or control blocks.
- Code folding with =C-c C-f= for HTML elements and control blocks.
- Snippet insertion with =C-c C-s= (auto indented, aware of text selection, engine
  specific).
- Clever selection and expansion with =C-c C-m=.

** Octave/Matlab
Open Matlab files (.m) in Octave mode by default.
#+begin_src emacs-lisp
  (setq auto-mode-alist
        (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+end_src

** R
Use ESS package ("Emacs Speaks Statistics") for editing R code.
#+begin_src emacs-lisp
  (use-package ess)
#+end_src

Some useful commands:
- =C-c C-b= to eval buffer.
- =C-c C-j= to eval line.
- =C-c C-r= to eval region.
- =C-c C-f= to eval function.

* Org Mode
Configuration for Org mode, one of the best major modes in Emacs (org mode is
definately a killed feature). Org mode is for keeping notes, maintaining to-do
lists, planning projects, authoring documents, computational notebooks,
literate programming and more — in a fast and effective plain text system.

** List Configuration
Allow alphabetical list, i.e., list like "a)", "A" or "A)" as element lists.
#+begin_src emacs-lisp
  (setq org-list-allow-alphabetical t)
#+end_src

** Indent Mode
Launch org mode in indent mode.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

** Speed Commands
Activate single letter commands at beginning of a headline.
#+begin_src emacs-lisp
  (setq org-use-speed-commands t)
#+end_src

This is very useful for navigating/modifying org mode files. I usually use
=n=/=p= for next/previous, =b=/=f= for backward/forward, and =l=/=r= for
left/right.

** Refile
Configuration for refiling command =C-c w=.
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 2)
                                  (org-agenda-files :maxlevel . 2)))
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-use-outline-path 'file)
#+end_src

** Capture templates
Permitir tomar notas rápidamente.
#+begin_src emacs-lisp
  (setq org-default-notes-file "~/Documents/Tasks.org")
  (define-key global-map (kbd "C-c c") 'org-capture)
#+end_src

Set my custom capture templates. Brief description of them:
- Standalone Tasks: main template for TODO tasks.
- Email Tasks: template for capturing emails I need to reply to (with link of
  course).
- Link Tasks: similar to standalone tasks, but with link (e.g., email or Elfeed
  link).
- Text: tempalte for taking quick notes.
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Standalone Tasks" entry
           (file+headline "~/Documents/Tasks.org" "Standalone Tasks")
           "* TODO [#C] %?" :empty-lines-before 1 :empty-lines-after 2)
          ("e" "Email" entry
           (file+headline "~/Documents/Tasks.org" "Email Tasks")
           "* TODO [#C] Reply: %a"
           :immediate-finish t :empty-lines-before 1 :empty-lines-after 2)
          ("l" "Link" entry
           (file+headline "~/Documents/Tasks.org" "Email")
           "* TODO [#C] %a" :empty-lines-before 1 :empty-lines-after 2)
          ("o" "Text" entry
           (file+headline "~/Documents/Notes.org" "Varios")
           "* %?" :empty-lines-before 1 :empty-lines-after 2)))
#+end_src

** State Keywords
Custom todo keywords. I use them as follows:
- TODO: task that needs to be done (in order, depending priority).
- WAIT: I am waiting for something that does not depend on myself (i.e,
  something external).
- NEXT: todo task, that is on-going or is next task to be done.
- DONE: task is done.
- CANCELLED: task is cancelled.
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "WAIT(w@/!)" "NEXT(n)" "|"
                    "DONE(d!)" "CANCELLED(c@)")))
#+end_src

For tracking TODO state changes, the meaning of the characters is as follows
(check [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][Tracking TODO state changes]] for more information): ! for timestamp and @
for note with timestamp.

Log state changes into drawer.
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

** Code Evaluation
Allow code blocks in these languages to be evaluated with =C-c C-c=.
#+begin_src emacs-lisp
  (eval-after-load "org"
        (org-babel-do-load-languages
         'org-babel-load-languages
         '((C . t)
           ;; (C++ . t)
           (python . t)
           (latex . t)
           (matlab . t)
           (shell . t)
           (css . t)
           (calc . t)
           (R . t)
           (js . t))))
#+end_src

Don't ask for confirmation for evaluating code.
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Interface
Cambiar los puntos suspensivos.
#+begin_src emacs-lisp :tangle no
  (setq org-ellipsis " ⚡")
#+end_src

Configurar colores para las diferentes prioridades.
#+begin_src emacs-lisp :tangle no
  (setq org-priority-faces '((65 :foreground "#e45649" :weight bold :face bold)
                             (66 :foreground "#dc752f" :weight bold :face bold)
                             (67 :foreground "#0098dd" :weight bold :face bold)))
#+end_src

Restore windows after quitting org agenda.
#+begin_src emacs-lisp
  (setq org-agenda-restore-windows-after-quit t)
  ;; (setq org-agenda-window-setup "current-window")
#+end_src

*** TODO =org-bullets=
Cambia los asteriscos por bolas. Aquí mirar el paquete =org-superstar= que es
una versión moderna de este. Y mirar qué lista de bolas poner.
#+begin_src emacs-lisp :tangle no
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook(lambda () (org-bullets-mode)))
    (setq org-bullets-bullet-list '("✙" "○" "✜" "✿")))
#+end_src

** Agenda
Comando para abrir la agenda.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

Gestionar los diferentes archivos para la Agenda.
#+begin_src emacs-lisp
  (setq org-agenda-files (quote
                          ("~/Documents/Contactos/Cumpleaños.org"
                          "~/Documents/UPC/Cuatrimestre 9/UPC.org"
                          ;; "~/Documents/UPC/Cuatrimestre 9/Schedule.org"
                          "~/Documents/Notes.org"
                          "~/Documents/Career/Career.org"
                          "~/Documents/Tasks.org")))
#+end_src

Configurar agenda personalizada.
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("w" "Week Agenda and all TODOs without schedule"
           ((agenda "" ((org-agenda-tag-filter-preset (quote ("-SCH")))))
            (alltodo "" ((org-agenda-tag-filter-preset (quote ("-SCH"))))))
           ((org-agenda-start-with-log-mode t)))
          ("d" "Current day"
           ((agenda "" ((org-agenda-span 'day)))))
          ("b" "Block Agenda"
           ((agenda ""
                    ((org-agenda-start-on-weekday nil)
                     (org-agenda-span 3)
                     ;; (org-agenda-start-day "-3d")
         (org-agenda-overriding-header "Main Week Agenda (Scheduled and Deadline Tasks)")
                     (org-agenda-skip-function
                      '(org-agenda-skip-entry-if 'regexp ":HABIT:"))))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next")
                   (org-agenda-skip-function
                           '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            (todo "WAIT"
                  ((org-agenda-overriding-header "Waiting")
                   (org-agenda-skip-function
                           '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            (tags-todo "TODO=\"TODO\"+PROJECT"
                       ((org-agenda-overriding-header "Projects")
                        (org-agenda-skip-function
                           '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            (tags-todo "TODO=\"TODO\"-PROJECT-HABIT-SOMEDAY"
                       ((org-agenda-overriding-header "Standalone Tasks")
                        (org-agenda-skip-function
                         '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            (agenda ""
                    ((org-agenda-span 'day)
                     (org-agenda-overriding-header "Daily Habits Agenda")
                     (org-agenda-skip-function
                      '(org-agenda-skip-entry-if 'notregexp ":HABIT:")))))
           ((org-agenda-start-with-log-mode t)))))
#+end_src

Set deadline warning days to 7 (instead of the default 14 days).
#+begin_src emacs-lisp
  (setq org-deadline-warning-days 7)
#+end_src

With =q= bury agenda instead of killing it (faster of course).
#+begin_src emacs-lisp
(setq org-agenda-sticky t)
#+end_src

*** Habits
Show a nice graph for recurring habits. See [[https://orgmode.org/manual/Tracking-your-habits.html][Tracking your Habits]] in the
Org-mode manual for more information.
#+begin_src emacs-lisp
  (require 'org-habit)
#+end_src

** Archive
Set default org archive location.
#+begin_src emacs-lisp
  (setq org-archive-location "~/Documents/Archive//%s::")
#+end_src

** Table of Contents
It’s nice to have a table of contents section (without exporting) for long
literate configuration files (like this one!) so I use org-toc-org to
automatically update the ToC in any header with a property named TOC.
#+begin_src emacs-lisp
  (use-package toc-org
    :hook (org-mode . toc-org-mode))
#+end_src

The default ToC depth is 2. Is possible to change this with the following tag
format =:TOC_3:= for seting the max depth of the headlines in the table of
contents to 3.

* Edición de documentos
** Markdown Mode
Major mode for editting Markdown-formatted text.
#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src

** LaTeX
Configuración de LaTeX con AUCTeX.
Siempre en modo matemático.
#+begin_src emacs-lisp :tangle no
  (use-package auctex
    :config
    ;; Always in math mode
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    ;; Set PDF viewer to pdf-tools with correlation
    (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
    (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
    ;; Close pairs automagically (electric behavior)
    (setq  LaTeX-electric-left-right-brace t)
    :bind (
           :map LaTeX-mode-map
           ;; Command for cleaning auxiliary files
           ("C-x M-k" . 'TeX-clean))
    )
#+end_src

Usar =reftex=.
- =C-c= show ToC.
- =C-c (= create label.
- =C-c )= reference label.
- =C-c [= create cite.
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (setq reftex-toc-split-windows-fraction 0.2)
#+end_src

#+begin_src emacs-lisp
  (setq LaTeX-item-indent 0)
#+end_src

*** Compilación
Compilar con =-shell-escape= siempre.
#+begin_src emacs-lisp
  (setq TeX-command-extra-options "-shell-escape -synctex=1")
#+end_src

No preguntar para guardar y actualizar el /pdf/ después de compilar.
#+begin_src emacs-lisp
  (setq TeX-save-query nil)
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
#+end_src

*** BibTeX
For managing .bib files. Use =C-c C-c=. Insert entries templates with different
key bindings. Also, =C-c C-f= for inserting new field.
#+begin_src emacs-lisp
  (setq bibtex-align-at-equal-sign t)
  (setq bibtex-entry-format `(opts-or-alts required-fields
                              numerical-fields whitespace realign
                              last-comma delimiters unify-case
                              braces sort-fields))
  (setq bibtex-autokey-year-title-separator ":")
#+end_src

* PDF Viewer
PDF Tools PDF Tools is, among other things, a replacement of DocView for PDF
files. The key difference is that pages are not pre-rendered by
e.g. ghostscript and stored in the file-system, but rather created on-demand
and stored in memory.

Disable here Swiper for searching, and fallback to Isearch, since Swiper
searchs in the source code rather than in the PDF itself.
#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (pdf-tools-install)
    :bind (:map pdf-view-mode-map
                ("C-s" . 'isearch-forward)))
#+end_src

Slices are really useful:
- =s r= reset slice.
- =s m= set slice with mouse.
- =s b= set slice using bounding box.

Multiple annotations commands are supported with keybind prefix =C-c C-a= (for
introducing is best to use the mouse for selecting position), and for listing
=C-c C-a l=.

For displaying PDF metadata the command is =I=.

Also, is pretty useful to list all lines containing a phrase (this is called
occur), and can be access using =M-s o=.

* Email Management
Configuration for email within Emacs with =mu4e=. Open last 7 days email header
view with =C-c e= keybinding. Disable asking for confirmation when killing.
#+begin_src emacs-lisp
  (require 'mu4e)
  (setq mail-user-agent 'mu4e-user-agent)
  (global-set-key (kbd "C-c e") (lambda()
                                  (interactive)
                                  (mu4e-headers-search "date:7d..now")))
  (setq mu4e-confirm-quit nil)
  #+end_src

Customization of header view. I don't use mailing lists that often, so I have
remove them from headers view.
#+begin_src emacs-lisp
  (setq mu4e-headers-fields '((:human-date . 10)
                              (:flags . 5)
                              (:from . 20)
                              (:subject)))
#+end_src

Add "ViewInbrowser" action in and view mode (in header mode this does not
work).
#+begin_src emacs-lisp
  (add-to-list 'mu4e-view-actions '("ViewInBrowser" .
  mu4e-action-view-in-browser) t)
#+end_src

Show complete email address in view mode.
#+begin_src emacs-lisp
  (setq mu4e-view-show-addresses t)
#+end_src

Set get mail command for syncing. And define keybind =C-c u= to just index
(without updating), this is faster.
#+begin_src emacs-lisp
  (setq mu4e-get-mail-command "mbsync -a -V")
  (define-key mu4e-headers-mode-map (kbd "C-c u") 'mu4e-update-index)
#+end_src

Enable images in mu4e view.
#+begin_src emacs-lisp
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))
  (setq mu4e-view-show-images t)
#+end_src

** Contexts for Multiple Accounts
I am using contexts for handling two different accounts at the same time. When
launching mu4e for the first time don't ask and just pick the first context
(the default).
#+begin_src emacs-lisp
  (setq mu4e-context-policy 'pick-first)
#+end_src

First, lets define basic configuration for both accounts (contexts in mu4e
terminology). This is, set maildir, my personal email addresses (used for not
replying to myself) and the behavior for sent messages.
#+begin_src emacs-lisp
  (setq mu4e-maildir "~/.mail")
  (setq mu4e-user-mail-address-list '("david@alvarezrosa.com"
                                      "david.alvarez.rosa@yandex.com"
                                      "davidolazegues@gmail.com"))
  (setq mu4e-sent-messages-behavior 'sent)
  (setq message-signature-file "~/.emacs.d/signature.txt")
#+end_src

The actual context accounts. Take into account that I am using the Spam/Junk
folders the same as refiling, and this is actually incorrect, but I do not use
any archive, so this is more useful for me.
#+begin_src emacs-lisp
  (setq mu4e-contexts
        `( ,(make-mu4e-context
             :name "Personal"
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/David" (mu4e-message-field msg :maildir))))
             :vars '(
                     (mu4e-inbox-folder . "/David/Inbox")
                     (mu4e-sent-folder . "/David/Sent")
                     (mu4e-drafts-folder . "/David/Drafts")
                     (mu4e-trash-folder . "/David/Inbox/Trash")
                     (mu4e-refile-folder . "/David/Inbox/Junk")
                     (smtpmail-stream-type . nil)
                     (user-mail-address . "david@alvarezrosa.com")
                     (smtpmail-starttls-credentials . '(("alvarezrosa.com" 587 nil nil)))
                     (smtpmail-default-smtp-server . "alvarezrosa.com")
                     (smtpmail-smtp-server . "alvarezrosa.com")
                     (smtpmail-smtp-service . 587)))
           ,(make-mu4e-context
             :name "Yandex"
             :match-func (lambda (msg)
                           (when msg
                             (string-match-p "^/Yandex" (mu4e-message-field msg :maildir))))
             :vars '(
                     (mu4e-inbox-folder . "/Yandex/Inbox")
                     (mu4e-sent-folder . "/Yandex/Sent")
                     (mu4e-drafts-folder . "/Yandex/Drafts")
                     (mu4e-trash-folder . "/Yandex/Trash")
                     (mu4e-refile-folder . "/Yandex/Spam")
                     (smtpmail-stream-type . ssl)
                     (user-mail-address . "david.alvarez.rosa@yandex.com")
                     (starttls-use-gnutls . t)
                     (smtpmail-smtp-server . "smtp.yandex.com")
                     (smtpmail-smtp-service . 465)))
           ))
#+end_src

** Queued Email
It allows to save the outgoing mail (output tray) to send them later. Useful
when working without an Internet connection, for example. This can be toggled
in mu4e main view with =m=.
#+begin_src emacs-lisp
  (setq smtpmail-queue-dir "~/.mail/Queue/cur")
#+end_src

** Signing and Encryption
Encriptar todos los correos salientes /automágicamente/ si la llave existe.
#+begin_src emacs-lisp :tangle no
  (defun david/can-encrypt-message-p ()
    "Return non-nil if current message can be encrypted.
  I.e., the keyring has a public key for each recipient."
    (let ((recipients
           (seq-map #'cadr ; only take email address, not recipient name
                    (seq-mapcat (lambda (header)
                                  (let ((header-value
                                         (message-fetch-field header)))
                                    (and header-value
                                         (mail-extract-address-components header-value
                                                                          t))))
                                '("To" "CC" "BCC"))))
          (context (epg-make-context epa-protocol)))
      (seq-every-p (lambda (recipient)
                     (not (seq-empty-p (epg-list-keys context recipient))))
                   recipients)))

  (defun david/add-encryption-mark-if-possible ()
    "Add MML tag to encrypt message when there is a key for each
  recipient."
    (when (david/can-encrypt-message-p)
      (mml-secure-message-sign-encrypt)))

  (add-hook 'message-send-hook #'david/add-encryption-mark-if-possible)
#+end_src

For signing emails (when the key is available).
#+begin_src emacs-lisp
  (setq mml-secure-openpgp-sign-with-sender t)
#+end_src

** Completion
Use Ivy as default completion engine (instead of Ido).
#+begin_src emacs-lisp
  (setq mu4e-completing-read-function 'ivy-completing-read)
#+end_src

I have personalized the email completion with a file with contact information
stored in =david/contact-file=. This text file has contacts in the form "Name
<address>", one per line. This function is inspired on [[http://pragmaticemacs.com/emacs/even-better-email-contact-completion-in-mu4e/][Even better email
contact completion in mu4e]].
#+begin_src emacs-lisp
  (setq david/contact-file "~/Documents/Contactos/Correos.txt")
  (defun david/read-contact-list ()
    (with-temp-buffer
      (insert-file-contents david/contact-file)
      (split-string (buffer-string) "\n" t)))
  (defun david/complete-emails (&optional start)
    (interactive)

    (let ((eoh ;; end-of-headers
           (save-excursion
             (goto-char (point-min))
             (search-forward-regexp mail-header-separator nil t))))

    ;; Only run if we are in the headers section
    (when (and eoh (> eoh (point)) (mail-abbrev-in-expansion-header-p))
      (let* ((end (point))
             (start
              (or start
                  (save-excursion
                    (re-search-backward "\\(\\`\\|[\n:,]\\)[ \t]*")
                    (goto-char (match-end 0))
                    (point))))
             (initial-input (buffer-substring-no-properties start end)))

        (delete-region start end)

        (ivy-read "Contact: "
                  (david/read-contact-list)
                  :action (lambda(contact) (with-ivy-window (insert contact)))
                  :initial-input initial-input)))))
  (define-key mu4e-compose-mode-map (kbd "<M-tab>") 'david/complete-emails)
#+end_src

** Composition/Sending
Set default send mail function.
#+begin_src emacs-lisp
  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src

Configure citation line (the one that says "On 20 April David wrote...") .
#+begin_src emacs-lisp
  (setq message-citation-line-function 'message-insert-formatted-citation-line)
  (setq message-citation-line-format "On %a %d %b %Y at %R, %N wrote:")
#+end_src

*** Org Mode HTML
This program sends HTML email using Org-mode HTML export. This approximates a
WYSiWYG HTML mail editor from within Emacs, and can be useful for sending
tables, fontified source code, and inline images in email. LaTeX formulas can
be sent using the modern math delimiters such as \(...\) and \[...\], and also
environments of any kind (the only requirement is that the ‘\begin’ statement
appears on a new line, preceded by only whitespace). It's very useful when
dealing with LaTeX formulas to use =C-c C-x C-l= for producing a preview image
of the LaTeX fragment at point and overlay it over the source code (f there is
no fragment at point, process all fragments in the current entry-—between two
headlines).
#+begin_src emacs-lisp
  (use-package org-mime
    :config
    (setq org-mime-export-options '(:with-latex dvipng
                                    :section-numbers nil
                                    :with-author nil
                                    :with-toc nil))
    :bind (:map message-mode-map
                (("C-c o" . 'org-mime-edit-mail-in-org-mode)
                 ("C-c M-o" . 'org-mime-htmlize))))
#+end_src

Some useful functions are =org-mime-edit-mail-in-org-mode= (press =C-c o=) for
editing the mail in a special buffer in Org mode, and then =org-mime-htmilize=
(with =C-c M-o=) from within a mail composition buffer to export either the
entire buffer or just the active region to html, and embed the results into the
buffer as a text/html mime section. After =org-mime-htmlize=, you can always
run =org-mime-revert-to-plain-text-mail= restore the original plain text mail.

For embedding image into mail body the syntax is as follows:
=[[/full/path/to/your.jpg]]=.

The function =org-mime-org-buffer-htmlize= can be called from an Org mode
buffer to export either he whole buffer or the narrowed subtree or active
region to HTML, and open a new email buffer including the resulting HTML
content as an embedded mime section.

The function =org-mime-org-subtree-htmlize= is similar to
=org-mime-org-buffer-htmlize= but works on subtree. It can also read subtree
properties MAIL_SUBJECT, MAIL_TO, MAIL_CC, and MAIL_BCC. Here is the sample of
subtree:
#+begin_example
  ,* mail one
   :PROPERTIES:
   :MAIL_SUBJECT: mail title
   :MAIL_TO: person1@gmail.com
   :MAIL_CC: person2@gmail.com
   :MAIL_BCC: person3@gmail.com
   :END:
  some text here ...
#+end_example

** Attachment Management
Configure attachment directory for downloading.
#+begin_src emacs-lisp
  (setq mu4e-attachment-dir "~/Downloads")
#+end_src

For attaching files while composing new email. To attach file, just mark in
dired and =C-c RET C-a=. This is useful for attaching multiple files, but the
default =C-c C-a= command for attaching (in composition buffer) works just
well.
#+begin_src emacs-lisp
  (require 'gnus-dired)
  (defun gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                   (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
#+end_src

* Music Player
Para controlar la reproducción de música desde Emacs. Debe estar instalado
=mpd= (Music Player Daemon) e interactuaremos con él haciendo uso del cliente
=mpc= construido en Emacs.

Para lanzarlo usar el comando =C-c m= ("m" de music) y luego quitarlo siempre
con =q=.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c m") 'mpc)
#+end_src

Algunos comandos para facilitar la interacción.
#+begin_src emacs-lisp
  (require 'mpc)
  (define-key mpc-mode-map "a" 'mpc-playlist-add)
  (define-key mpc-mode-map "l" 'mpc-playlist)
  (define-key mpc-mode-map "d" 'mpc-playlist-delete)
#+end_src

* Web Feed Reader
Elfeed is an extensible web feed reader for Emacs, supporting both Atom and
RSS. It requires Emacs 24.3.
#+begin_src emacs-lisp
  (use-package elfeed
    :bind ("C-c f" . 'elfeed)
    :config (setq elfeed-db-directory "~/.emacs.d/elfeed"
                  elfeed-search-filter "@1-week-ago -no "
                  elfeed-search-title-max-width 100))
#+end_src

** Elfeed Org
Use Elfeed Org for managing subscriptions to RSS/Atom feeds using an org mode
file.
#+begin_src emacs-lisp
  (use-package elfeed-org
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list "~/Documents/Suscripciones.org")))
#+end_src

** Elfeed Goodies
This package allows to configure the Elfeed interface.
#+begin_src emacs-lisp
  (use-package elfeed-goodies
    :config
    (elfeed-goodies/setup)
    (setq elfeed-goodies/powerline-default-separator 'utf-8)
    (setq elfeed-goodies/entry-pane-size 0.40))
#+end_src

** Custom Functions
For interacting with video (e.g., Youtube subscriptions). This allows to open
the media with mpv. Just press =v= and the video will be openend with mpv.
#+begin_src emacs-lisp
  (defun david/elfeed-play-with-mpv ()
    (interactive)
    (setq url (elfeed-entry-link (elfeed-search-selected :single)))
    (start-process "elfeed-mpv" nil "mpv" "--ytdl-format=[height<=720]" url)
    (elfeed-search-untag-all-unread))
  (define-key elfeed-search-mode-map (kbd "v") 'david/elfeed-play-with-mpv)
#+end_src

Ignore current entry (i.e., tag it with =no= TAG).
#+begin_src emacs-lisp
  (defun david/elfeed-ignore ()
    (interactive)
    (setq entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
    (setq tag (intern "no"))
    (elfeed-tag entry tag)
    (elfeed-search-update-entry entry)
    (forward-line))
  (define-key elfeed-show-mode-map (kbd "i") 'david/elfeed-ignore)
  (define-key elfeed-search-mode-map (kbd "i") 'david/elfeed-ignore)
#+end_src

* Internet Relay Chat (IRC)
IRC is a text-based chat system. It enables discussions among any number of
participants in so-called conversation channels, as well as discussions between
only two partners--for example, in question-and-answer dialogues. This
protocol is actually older than the World Wide Web. There are several built-in
Emacs IRC clients, but I use the default ERC, that I think is the best one. I
have bind the ERC client, with TLS support, to =C-c i= ("i" for IRC).
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c i") 'erc-tls)

  (setq erc-server "irc.libera.chat")
  (setq erc-nick "dalv")
  (setq erc-user-full-name "David Álvarez Rosa")
  (setq erc-autojoin-channels-alist '(("libera.chat"
                                       "#emacs" "#archlinux")))
#+end_src

If you are an IRC user, you may find me out there. I usually hang out in
libera.chat these days (after the freenode management debacle) with the =dalv=
nick.

After quiting server, query or parting a channel I want the buffer to be killed
automatically.
#+begin_src emacs-lisp
  (setq erc-kill-buffer-on-part t)
  (setq erc-kill-queries-on-quit t)
  (setq erc-kill-server-buffer-on-quit t)
  (setq erc-quit-reason (lambda (s) (or s "Ejecting from cyberspace")))
#+end_src

Some minor tweaks for displaying (and buffer) configuration.
#+begin_src emacs-lisp
  (setq erc-fill-function 'erc-fill-static)
  (setq erc-fill-static-center 22)
  (setq erc-rename-buffers t)
#+end_src

I use ERC channel tracking (it is enabled by default). Basically, show in the
modeline unread chat messages from current openend channels and use =C-c C-SPC=
repeatedly for switching between them (in *any* mode).
#+begin_src emacs-lisp
  (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE" "AWAY"))
  (setq erc-track-exclude-server-buffer t)
#+end_src

* Useful Resources
- [[https://github.com/daedreth/UncleDavesEmacs][Dawid Eckert]] has a Youtube channel with nice Emacs tutorials (is called
  UncleDave).
- [[https://github.com/mxco86/emacs-config/blob/master/.emacs.d/emacs.org][Matthew Ryall]]
- [[https://github.com/daviwil/dotfiles/blob/master/Emacs.org][David Wilson]] is the owner of SystemCrafters channel.
- [[https://github.com/munen/emacs.d][Alain M. Lafon]] is the author of "Play Emacs like an instrument" video, and
  has a very neat configuration.
- [[https://gitlab.com/protesilaos/dotfiles/-/blob/master/emacs/.emacs.d/prot-emacs.org][Protesilaos Stavrou]] this guy is amazing, he also has a youtube channel.
- [[https://github.com/bradwright/emacs.d][Bradley Wright]]
- [[https://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua ]]she is a well known Emacs blogger.
- [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]] is a community driven list of useful Emacs packages, utilities
  and libraries
- [[http://doc.norang.ca/org-mode.html][Bernt Hansen]] has an amazing Org mode configuration.
- [[https://github.com/SirPscl/emacs.d][Pascal Huber]] another nice Emacs configuration to take into account.
- [[https://cestlaz.github.io/stories/emacs/][Mike Zamansky]] a well known Emacs guru, that has a blog called "C'est la Z"
  with a nice Emacs series (+75 blog entries, each one of them with video).
